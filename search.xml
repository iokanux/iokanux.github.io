<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>XCPC中的时间技巧</title>
    <url>/2024/09/08/XCPC/Tips/XCPC%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>除了时间复杂度,还有什么会影响程序的运行时间</p>
<span id="more"></span>

<p>本文只来自于自己的做题经验，并没有其他来源，欢迎纠错</p>
<p>可供验证的题目有</p>
<ol>
<li><a href="https://ac.nowcoder.com/acm/contest/7501/A">A-Intelligent Warehouse_2020ICPC·小米 网络选拔赛第一场 (nowcoder.com)</a></li>
</ol>
<h2 id="int-与-long-long"><a href="#int-与-long-long" class="headerlink" title="int 与 long long"></a>int 与 long long</h2><p>开long long 会极大增加程序运行的时间,所以建议仔细判断题目是否有开long long的必要,而不是每道题都加#define int long long </p>
<h2 id="宏定义与替换"><a href="#宏定义与替换" class="headerlink" title="宏定义与替换"></a>宏定义与替换</h2><ol>
<li><p>宏定义(#define)会增加运行时间</p>
</li>
<li><p>替换(typedef&#x2F;const&#x2F;constexpr&#x2F;using)也会增加运行时间</p>
</li>
</ol>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>Tips</category>
      </categories>
  </entry>
  <entry>
    <title>2024CCPC网络赛</title>
    <url>/2024/09/12/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/2024CCPC%E7%BD%91%E7%BB%9C%E8%B5%9B/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="B-军训-II"><a href="#B-军训-II" class="headerlink" title="B 军训 II"></a>B 军训 II</h2><p>对于这类问题一个很经典的思路就是求每个位置的贡献</p>
<p>首先能感性的判断出来从小到大&#x2F;从大到小排不整齐度是最小的(因为最大&#x2F;最小值都是依次递增的)</p>
<p>然后可以理性的证明一下：</p>
<p>对于已经排好序的数组a 有a1&lt;&#x3D;a2&lt;&#x3D;a3&lt;&#x3D;…&lt;&#x3D;an,此时交换a2,ak(假设a2&lt;ak);</p>
<p>交换完的结果就是l在[1,k-1],r在[l,k-1]的区间内最大值变大，最小值不变,l在[k,n]，r在[l,n]的区间内最大值不变，最小值变小</p>
<p>身高相同的人可以交换位置,$A_{k}^k$,表示k个身高相同的人的排列方案,</p>
<p>注意特判全相等序列(从小到大和从大到小排列一样)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n);</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];mp[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">            ans1+=a[j]-a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> A=[&amp;](<span class="type">int</span> x)&#123;</span><br><span class="line">        <span class="type">int</span> tem=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)&#123;</span><br><span class="line">            tem=(tem*i)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tem;</span><br><span class="line">    &#125;;</span><br><span class="line">    a.<span class="built_in">erase</span>(<span class="built_in">unique</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:a)&#123;</span><br><span class="line">        ans2=(ans2*<span class="built_in">A</span>(mp[i]))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()!=<span class="number">1</span>) ans2=(ans2*<span class="number">2</span>)%mod;</span><br><span class="line">    cout&lt;&lt;ans1&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ans2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="K-取沙子游戏"><a href="#K-取沙子游戏" class="headerlink" title="K 取沙子游戏"></a>K 取沙子游戏</h2><p>考虑n的奇偶性</p>
<p>当n为奇数时，第一手取1必然获胜</p>
<p>当n为偶数时，考虑变成必胜态，即将n减去某两个数得到奇数，可知这两个数必然为一奇一偶，且先手必选偶数，当先手选择奇数后，后手必胜。</p>
<p>由于选择的是偶数，初步猜想寄了，因为后手必然不会选择奇数，所以后手选择偶数阻止先手到达必胜态，此时第二轮到达先手手上的数还是偶数，这样归纳一下可以发现当n为偶数的时候，先后手都只会选择偶数</p>
<p>考虑二进制，当先手第一次选择lowbit(n)时，后手无论选择什么我们都和其选择一样即可获胜，因为二进制下需要偶数次选择偶数才能将这个数归零</p>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>XCPC系列赛</category>
      </categories>
  </entry>
  <entry>
    <title>ICPC·2020·小米网络赛二</title>
    <url>/2024/09/11/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/ICPC%C2%B72020%C2%B7%E5%B0%8F%E7%B1%B3%E7%BD%91%E7%BB%9C%E8%B5%9B%E4%BA%8C/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="G-Shift-and-Reverse"><a href="#G-Shift-and-Reverse" class="headerlink" title="G Shift and Reverse"></a>G Shift and Reverse</h2><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>Bobo has a sequence $a_1,a_2,\dots,a_n$. He can rearrange the sequence using the following operation any number of times:  </p>
<p>+ Select an integer i ($1 \le i \le n$) and change the sequence to $a_i, a_{i-1}, \dots, a_1, a_n, a_{n-1}, \dots, a_{i+1}$.  </p>
<p>Bobo would like to know the number of different sequences can be obtained modulo $(10^9+7)$.</p>
<p>波波有一个序列$a_1,a_2,\dots,a_n$。他可以使用以下操作任意次数重新排列序列:</p>
<p>选择整数i($1 \le i \le n$)并将序列更改为$a_i, a_{i-1}, \dots, a_1, a_n, a_{n-1}, \dots, a_{i+1}$。</p>
<p>Bobo想知道有多少个不同的序列对$(10^9+7)$取模。</p>
<h3 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse"></a>Analyse</h3><p>遇到题目没思路就先模拟一下</p>
<p>一个新的数组a,标号从a1-an,假定选择k进行反转操作，执行操作后的序列为$a_{k},a_{k-1}…a_{k+2},a_{k+1},$</p>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>XCPC系列赛</category>
      </categories>
  </entry>
  <entry>
    <title>ICPC网络赛第一场</title>
    <url>/2024/09/08/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/ICPC%E7%BD%91%E7%BB%9C%E8%B5%9B%E7%AC%AC%E4%B8%80%E5%9C%BA/</url>
    <content><![CDATA[<h2 id="A-Intelligent-Warehouse"><a href="#A-Intelligent-Warehouse" class="headerlink" title="A  Intelligent Warehouse"></a>A  Intelligent Warehouse</h2><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>In <em>MI Intelligent Warehouse</em>, there are $n_{}$ products, where the $i_{}$-th product is of size $a_i$. We always need to box producsts into all kinds of containers, and it will be safer and more cost efficient(效率高的) if for any two sizes of products, one is the other’s multiple, since(因为) there won’t be any residual(残余的) room in one container. So for each boxing we need to choose some products that for any two chosen products, either $a_i$ is multiple of $a_j$ or $a_j$ is multiple of $a_i$. Print the maximum number of products that can be chosen in one boxing.</p>
<p>在mi智能仓库中，有$n_{}$个产品，其中$i_{}$个产品的尺寸为$a_i$。我们总是需要把产品装进各种各样的容器中，如果任意两个尺寸的产品，一个是另一个的倍数，这样会更安全且成本效益更高，因为一个容器里不会有剩余的空间。因此，对于每次装箱，我们需要选择一些产品，对于任意两个选择的产品，要么是$a_i$是$a_j$的倍数，要么是$a_j$是$a_i$的倍数。打印出在一次装箱中选择的产品的最大数量。</p>
<h3 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse"></a>Analyse</h3><p>目的是选择若干个数字，其中任意两个数均成倍数关系</p>
<p>考虑最终选定的序列，将其排序后，每个数都必然是最大数的约数，所以其实存在一种递推关系，当$ai$是某个数列的最大数时，将$ai$的倍数加进来，整个数列必然也满足条件</p>
<p>考虑dp，dp[i]表示以i结尾的最长序列，dp关系式也如上文所说</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> N=<span class="number">1e7</span>;</span><br><span class="line"><span class="type">int</span> dp[N<span class="number">+10</span>],mp[N<span class="number">+10</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        mp[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[i])&#123;</span><br><span class="line">            dp[i]+=mp[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">2</span>;j&lt;=N;j+=i)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[i],dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-Intelligent-Robot"><a href="#B-Intelligent-Robot" class="headerlink" title="B  Intelligent Robot"></a>B  Intelligent Robot</h2><h2 id="C-Smart-Browser"><a href="#C-Smart-Browser" class="headerlink" title="C  Smart Browser"></a>C  Smart Browser</h2><h3 id="Topic-1"><a href="#Topic-1" class="headerlink" title="Topic"></a>Topic</h3><p>In some social platforms(社交平台), there are some netizen(平台) who like to post “<em>www</em>“. Since the string is like the grass(草), which contains plenty of “&#x2F;\“ shapes, so there are also some netizen who post “<em>grass</em>“.  </p>
<p>As a fast, smart, and convenient browser, <em>MI Browser</em> can recognize this kind of text and show some special effects. Specifically(具体来说), given a string, <em>MI Browser</em> will determine(确定) the number of “&#x2F;\“ shapes made by character “<em>w</em>“, where “<em>w</em>“ itself and the gap(间隙) between two adjacent(相邻的) “<em>w</em>“s both give one `&#x2F;\` shape. If still not clear, please turn to sample input&#x2F;output for more details.  </p>
<p>As a <em>MI fan</em>, you want to detect(探究) the relationship between the special effects and the number of “&#x2F;\“ shapes, so the thing you should do first is to determine the number of “&#x2F;\“ shapes by yourself.</p>
<p>在一些社交平台上，有些网民喜欢发布“www”。由于这个字符串看起来很像草，其中包含了许多“&#x2F;\”的形状，因此也有一些网民发布“grass”。</p>
<p>作为一款快速、智能且便捷的浏览器，MI浏览器能够识别这种文本并展示一些特殊效果。具体来说，给定一个字符串，MI浏览器会确定由字符“w”构成的“&#x2F;\”形状的数量，其中“w”本身以及两个相邻“w”之间的间隙都构成一个“&#x2F;\”形状。如果仍然不清楚，请参考示例输入输出以获取更多详情。</p>
<p>作为MI浏览器的粉丝，你想要探究这些特殊效果与“&#x2F;\”形状数量之间的关系，因此你首先要做的就是自己确定“&#x2F;\”形状的数量。</p>
<h3 id="Analyse-1"><a href="#Analyse-1" class="headerlink" title="Analyse"></a>Analyse</h3><p>双指针判断以v分隔开的w的字符数量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;w&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(s[i<span class="number">+1</span>]==<span class="string">&#x27;w&#x27;</span>&amp;&amp;i<span class="number">+1</span>&lt;s.<span class="built_in">length</span>())&#123;</span><br><span class="line">                i++;cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=<span class="number">2</span>*cnt<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>XCPC</category>
        <category>XCPC系列赛</category>
      </categories>
  </entry>
  <entry>
    <title>子序列相关</title>
    <url>/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AD%90%E5%BA%8F%E5%88%97%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>动态规划中的子序列问题</p>
<span id="more"></span>

<p>子序列(subsequence)不要求连续，但相对顺序不能改变</p>
<h2 id="最长上升子序列-LIS"><a href="#最长上升子序列-LIS" class="headerlink" title="最长上升子序列(LIS)"></a>最长上升子序列(LIS)</h2><p>Longest Increasing Subsequence</p>
<h3 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dp[i]表示以num[i]结尾的最长上升子序列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    dp[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[j]&lt;num[i])&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i],dp[j]<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="O-nlogn"><a href="#O-nlogn" class="headerlink" title="O(nlogn)"></a>O(nlogn)</h3><p>二分法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;stk;<span class="comment">//模拟堆栈</span></span><br><span class="line">    stk.<span class="built_in">push_back</span>(a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;stk.<span class="built_in">back</span>())&#123;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            *<span class="built_in">lower_bound</span>(stk.<span class="built_in">begin</span>(),stk.<span class="built_in">end</span>(),a[i])=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//stk.size()为LIS长度</span></span><br></pre></td></tr></table></figure>

<h2 id="最长下降子序列-LDS"><a href="#最长下降子序列-LDS" class="headerlink" title="最长下降子序列(LDS)"></a>最长下降子序列(LDS)</h2><p>Longest Decreasing Subsequence,反方向的LIS</p>
<h3 id="O-nlogn-1"><a href="#O-nlogn-1" class="headerlink" title="O(nlogn)"></a>O(nlogn)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;stk;<span class="comment">//模拟堆栈</span></span><br><span class="line">    stk.<span class="built_in">push_back</span>(a[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;stk.<span class="built_in">back</span>())&#123;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            *<span class="built_in">lower_bound</span>(stk.<span class="built_in">begin</span>(),stk.<span class="built_in">end</span>(),a[i])=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长不上升子序列-LNIS"><a href="#最长不上升子序列-LNIS" class="headerlink" title="最长不上升子序列(LNIS)"></a>最长不上升子序列(LNIS)</h2><p>Longest Non-increasing Subsequence</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stk.<span class="built_in">push_back</span>(a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=stk.<span class="built_in">back</span>())&#123;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            *<span class="built_in">upper_bound</span>(stk.<span class="built_in">begin</span>(),stk.<span class="built_in">end</span>(),a[i],<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;())=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h2><p>Longest Common Subsequence</p>
<h3 id="O-nm"><a href="#O-nm" class="headerlink" title="O(nm)"></a>O(nm)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        dp[i][j]=<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">        <span class="keyword">if</span>(s[i]==t[j])&#123;</span><br><span class="line">           dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="O-nlogm"><a href="#O-nlogm" class="headerlink" title="O(nlogm)"></a>O(nlogm)</h3><p>一般情况下时间复杂度为O(nlogm)，但是最坏可退化至O(nm)</p>
<p>具体就是将LCS问题转化为LIS问题来做</p>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>XCPC模板</category>
        <category>XCPC动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>对拍</title>
    <url>/2024/09/07/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%9F%BA%E7%A1%80/%E5%AF%B9%E6%8B%8D/</url>
    <content><![CDATA[<p>介绍Windows环境下与Linux环境下的对拍</p>
<span id="more"></span>

<h2 id="Windows环境"><a href="#Windows环境" class="headerlink" title="Windows环境"></a>Windows环境</h2><p>以DEV为例，首先建四个源代码到一个新建文件夹中，源代码分别命名为wa.cpp,data.cpp,violent.cpp,windows.cpp,除此之外什么也不需要添加</p>
<ol>
<li>一份错误的&#x2F;需要比对的代码，导入wa.cpp</li>
<li>一份暴力的&#x2F;用来比对的代码，导入violent.cpp</li>
<li>一份用来造数据的代码</li>
<li>一份执行对拍程序的代码</li>
</ol>
<h3 id="wa-cpp"><a href="#wa-cpp" class="headerlink" title="wa.cpp"></a>wa.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="comment">//读入数据生成器造出来的数据</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;wa.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout); <span class="comment">//输出答案</span></span><br><span class="line">	<span class="comment">//下方注释为你的程序</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	int a, b;</span></span><br><span class="line"><span class="comment">	cin &gt;&gt; a &gt;&gt; b;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; a;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="violent-cpp"><a href="#violent-cpp" class="headerlink" title="violent.cpp"></a>violent.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);      <span class="comment">//读入数据生成器造出来的数据</span></span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;violent.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout); <span class="comment">//输出答案</span></span><br><span class="line">	<span class="comment">//下方程序为你已经导入的程序</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	int a, b;</span></span><br><span class="line"><span class="comment">	cin &gt;&gt; a &gt;&gt; b;</span></span><br><span class="line"><span class="comment">	cout &lt;&lt; a + b;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="data-cpp"><a href="#data-cpp" class="headerlink" title="data.cpp"></a>data.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">_timeb</span> T;</span><br><span class="line">	_ftime(&amp;T);</span><br><span class="line">	<span class="built_in">srand</span>(T.millitm); <span class="comment">//获得毫秒，减小运行时间</span></span><br><span class="line">	<span class="type">int</span> a = <span class="built_in">rand</span>(); <span class="comment">//此时a是一个随机数字</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="windows-cpp"><a href="#windows-cpp" class="headerlink" title="windows.cpp"></a>windows.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">//一直循环，直到找到不一样的数据</span></span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;data.exe&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;violent.exe&quot;</span>);</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;wa.exe&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">system</span>(<span class="string">&quot;fc wa.txt violent.txt&quot;</span>)) <span class="comment">//当 fc 返回 1 时，说明这时数据不一样</span></span><br><span class="line">			<span class="keyword">break</span>;                          <span class="comment">//不一样就跳出循环</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，以上所有程序均需要编译并运行</strong></p>
<p>当出现不同的结果时候，结果图片如下</p>
<p><img data-src="/iokanux.com/img/202409072335187.png" alt="image-20240907233526088"></p>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>XCPC模板</category>
        <category>XCPC基础</category>
      </categories>
  </entry>
  <entry>
    <title>矩阵相关</title>
    <url>/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E8%AE%BA/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="Matrix-Determinant-Lemma-矩阵行列式引理"><a href="#Matrix-Determinant-Lemma-矩阵行列式引理" class="headerlink" title="Matrix Determinant Lemma(矩阵行列式引理)"></a>Matrix Determinant Lemma(矩阵行列式引理)</h2><h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><p>对于可逆矩阵A,存在det($A+uv^T$)&#x3D;det(A)*($1+v^TA^{-1}u$)</p>
<h3 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h3><ol>
<li><a href="https://ac.nowcoder.com/acm/contest/7502/D">D-Determinant_2020ICPC·小米 网络选拔赛第二场 (nowcoder.com)</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>XCPC模板</category>
        <category>XCPC数论</category>
      </categories>
  </entry>
  <entry>
    <title>前缀和与差分</title>
    <url>/2024/09/04/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%9F%BA%E7%A1%80/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="前缀和-Prefix-Sum"><a href="#前缀和-Prefix-Sum" class="headerlink" title="前缀和(Prefix Sum)"></a>前缀和(Prefix Sum)</h2><p>通过构建前缀和数组，从而能做到O(1)时间复杂度的区间查询(rangeQuery)</p>
<h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><h4 id="构建前缀和数组"><a href="#构建前缀和数组" class="headerlink" title="构建前缀和数组"></a>构建前缀和数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">pre</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pre[i]=pre[i<span class="number">-1</span>]+a[i];</span><br></pre></td></tr></table></figure>

<h4 id="rangeQuery"><a href="#rangeQuery" class="headerlink" title="rangeQuery"></a>rangeQuery</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pre[r]-pre[l<span class="number">-1</span>]<span class="comment">//求(l,r)区间和</span></span><br></pre></td></tr></table></figure>

<h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><h4 id="构建前缀和数组-1"><a href="#构建前缀和数组-1" class="headerlink" title="构建前缀和数组"></a>构建前缀和数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">pre</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        pre[i][j]=pre[i<span class="number">-1</span>][j]+pre[i][j<span class="number">-1</span>]-pre[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">        <span class="comment">//pre[i][j]表示(1,1)为左上角,(i,j)为右下角的矩阵的和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="rangeQuery-1"><a href="#rangeQuery-1" class="headerlink" title="rangeQuery"></a>rangeQuery</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pre[x2][y2]-pre[x2][y1<span class="number">-1</span>]-pre[x1<span class="number">-1</span>][y2]+pre[x1<span class="number">-1</span>][y1<span class="number">-1</span>];</span><br><span class="line"><span class="comment">//求左上角为(x1,y1)，右下角为(x2,y2)的矩阵和    </span></span><br></pre></td></tr></table></figure>

<h2 id="差分-Difference"><a href="#差分-Difference" class="headerlink" title="差分(Difference)"></a>差分(Difference)</h2><p>通过构建差分数组，从而能做到O(1)时间复杂度的区间修改(rangeModify)</p>
<h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><h4 id="构建差分数组"><a href="#构建差分数组" class="headerlink" title="构建差分数组"></a>构建差分数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">dif</span>(n<span class="number">+5</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dif[i]=a[i]-a[i<span class="number">-1</span>];</span><br></pre></td></tr></table></figure>

<h4 id="rangeModify"><a href="#rangeModify" class="headerlink" title="rangeModify"></a>rangeModify</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dif[l]+=k;dif[r<span class="number">+1</span>]-=k;<span class="comment">//(l,r)区间每个数都加k</span></span><br></pre></td></tr></table></figure>

<h4 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i]+=b[i<span class="number">-1</span>];<span class="comment">//此时b[i]就是修改完后的第i个数的值</span></span><br></pre></td></tr></table></figure>

<h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p>与一维差分不同的是，二维差分数组的构建与修改均可以通过差分函数来完成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dif</span>(n<span class="number">+5</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+5</span>));</span><br><span class="line"><span class="keyword">auto</span> modify=[&amp;](<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> x)&#123;</span><br><span class="line">    dif[x1][y1]+=x;</span><br><span class="line">    dif[x1][y2<span class="number">+1</span>]-=x;</span><br><span class="line">    dif[x2<span class="number">+1</span>][y1]-=x;</span><br><span class="line">    dif[x2<span class="number">+1</span>][y2<span class="number">+1</span>]+=x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="构建差分数组-1"><a href="#构建差分数组-1" class="headerlink" title="构建差分数组"></a>构建差分数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        <span class="built_in">modify</span>(i,j,i,j,a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="rangeModify-1"><a href="#rangeModify-1" class="headerlink" title="rangeModify"></a>rangeModify</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">modify</span>(x1,y1,x2,y2,x);<span class="comment">//对左上角为(x1,y1),右下角为(x2,y2)的矩阵每个数都加上x</span></span><br></pre></td></tr></table></figure>

<h4 id="Query-1"><a href="#Query-1" class="headerlink" title="Query"></a>Query</h4><p>前缀和求</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        dif[i][j]+=dif[i<span class="number">-1</span>][j]+dif[i][j<span class="number">-1</span>]-dif[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">//pre[i][j]表示(1,1)为左上角,(i,j)为右下角的矩阵的和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>XCPC模板</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度</title>
    <url>/2024/09/07/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%9F%BA%E7%A1%80/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<p>高精度的封装板子</p>
<span id="more"></span>

<h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><p>每个操作的时间复杂度均为O(len)，涉及到两个大数参与的操作时为O(max(len1,len2))</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5005</span>;<span class="comment">//位数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bign</span>&#123;</span><br><span class="line">    <span class="type">int</span> len, s[MAXN];</span><br><span class="line">    <span class="built_in">bign</span> ()&#123;  </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in">sizeof</span>(s));</span><br><span class="line">        len = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bign</span> (<span class="type">int</span> num) &#123; *<span class="keyword">this</span> = num; &#125;</span><br><span class="line">    <span class="built_in">bign</span> (<span class="type">const</span> <span class="type">char</span> *num) &#123; *<span class="keyword">this</span> = num; &#125;  <span class="comment">//让this指针指向当前字符串</span></span><br><span class="line">    bign <span class="keyword">operator</span> = (<span class="type">const</span> <span class="type">int</span> num)&#123;</span><br><span class="line">        <span class="type">char</span> s[MAXN];</span><br><span class="line">        <span class="built_in">sprintf</span>(s, <span class="string">&quot;%d&quot;</span>, num);  <span class="comment">//sprintf函数将整型映到字符串中</span></span><br><span class="line">        *<span class="keyword">this</span> = s;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">//再将字符串转到下面字符串转化的函数中</span></span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> = (<span class="type">const</span> <span class="type">char</span> *num)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; num[i] == <span class="string">&#x27;0&#x27;</span>; num++) ;  <span class="comment">//去前导0</span></span><br><span class="line">        len = <span class="built_in">strlen</span>(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) s[i] = num[len-i<span class="number">-1</span>] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//反着存</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> + (<span class="type">const</span> bign &amp;b) <span class="type">const</span>&#123; </span><br><span class="line">    <span class="comment">//对应位相加，最为简单</span></span><br><span class="line">        bign c;</span><br><span class="line">        c.len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, g = <span class="number">0</span>; g || i &lt; <span class="built_in">max</span>(len, b.len); i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = g;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; len) x += s[i];</span><br><span class="line">            <span class="keyword">if</span>(i &lt; b.len) x += b.s[i];</span><br><span class="line">            c.s[c.len++] = x % <span class="number">10</span>;  <span class="comment">//关于加法进位</span></span><br><span class="line">            g = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> += (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        <span class="comment">//如上文所说，此类运算符皆如此重载</span></span><br><span class="line">        *<span class="keyword">this</span> = *<span class="keyword">this</span> + b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clean</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="comment">//由于接下来的运算不能确定结果的长度，先大而估之然后再查</span></span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">1</span> &amp;&amp; !s[len<span class="number">-1</span>]) len--;  <span class="comment">//首位部分‘0’故删除该部分长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> * (<span class="type">const</span> bign &amp;b)&#123; </span><br><span class="line">    <span class="comment">//乘法重载在于列竖式，再将竖式中的数转为抽象，即可看出运算法则。</span></span><br><span class="line">        bign c;</span><br><span class="line">        c.len = len + b.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; b.len; j++)&#123;</span><br><span class="line">                c.s[i+j] += s[i] * b.s[j];<span class="comment">//不妨列个竖式看一看</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.len; i++)&#123; </span><br><span class="line">            <span class="comment">//关于进位，与加法意同</span></span><br><span class="line">            c.s[i<span class="number">+1</span>] += c.s[i]/<span class="number">10</span>;</span><br><span class="line">            c.s[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c.<span class="built_in">clean</span>();  <span class="comment">//我们估的位数是a+b的长度和，但可能比它小（1*1 = 1）</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> *= (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        *<span class="keyword">this</span> = *<span class="keyword">this</span> * b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> - (<span class="type">const</span> bign &amp;b)&#123;  </span><br><span class="line">    <span class="comment">//对应位相减，加法的进位改为借1</span></span><br><span class="line">        <span class="comment">//不考虑负数</span></span><br><span class="line">        bign c;</span><br><span class="line">        c.len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, g = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = s[i] - g;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; b.len) x -= b.s[i];  <span class="comment">//可能长度不等</span></span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span>) g = <span class="number">0</span>;  <span class="comment">//是否向上移位借1</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                g = <span class="number">1</span>;</span><br><span class="line">                x += <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            c.s[c.len++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        c.<span class="built_in">clean</span>();</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> -= (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        *<span class="keyword">this</span> = *<span class="keyword">this</span> - b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> / (<span class="type">const</span> bign &amp;b) &#123;</span><br><span class="line">    <span class="comment">//运用除是减的本质，不停地减，直到小于被减数</span></span><br><span class="line">        bign c, f = <span class="number">0</span>; <span class="comment">//可能会在使用减法时出现高精度运算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;  </span><br><span class="line">            <span class="comment">//正常顺序，从最高位开始</span></span><br><span class="line">            f = f*<span class="number">10</span>;  <span class="comment">//上面位的剩余到下一位*10</span></span><br><span class="line">            f.s[<span class="number">0</span>] = s[i];  <span class="comment">//加上当前位</span></span><br><span class="line">            <span class="keyword">while</span>(f &gt;= b)&#123;</span><br><span class="line">                f -= b;</span><br><span class="line">                c.s[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c.len = len;  <span class="comment">//估最长位</span></span><br><span class="line">        c.<span class="built_in">clean</span>();</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> /= (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        *<span class="keyword">this</span>  = *<span class="keyword">this</span> / b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> % (<span class="type">const</span> bign &amp;b)&#123;  </span><br><span class="line">    <span class="comment">//取模就是除完剩下的</span></span><br><span class="line">        bign r = *<span class="keyword">this</span> / b;</span><br><span class="line">        r = *<span class="keyword">this</span> - r*b;</span><br><span class="line">        r.<span class="built_in">clean</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> %= (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        *<span class="keyword">this</span> = *<span class="keyword">this</span> % b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> bign &amp;b)&#123; </span><br><span class="line">    <span class="comment">//字符串比较原理</span></span><br><span class="line">        <span class="keyword">if</span>(len != b.len) <span class="keyword">return</span> len &lt; b.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len<span class="number">-1</span>; i != <span class="number">-1</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != b.s[i]) <span class="keyword">return</span> s[i] &lt; b.s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &gt; (<span class="type">const</span> bign &amp;b)&#123;  </span><br><span class="line">    <span class="comment">//同理</span></span><br><span class="line">        <span class="keyword">if</span>(len != b.len) <span class="keyword">return</span> len &gt; b.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len<span class="number">-1</span>; i != <span class="number">-1</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != b.s[i]) <span class="keyword">return</span> s[i] &gt; b.s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> &gt; b) &amp;&amp; !(*<span class="keyword">this</span> &lt; b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> == b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;= (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> &lt; b || *<span class="keyword">this</span> == b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &gt;= (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> &gt; b || *<span class="keyword">this</span> == b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">()</span> <span class="type">const</span></span>&#123;  </span><br><span class="line">    <span class="comment">//将结果转化为字符串（用于输出）</span></span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) res = <span class="built_in">char</span>(s[i]+<span class="string">&#x27;0&#x27;</span>)+res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream &amp;in, bign &amp;x)&#123;</span><br><span class="line"><span class="comment">//重载输入流</span></span><br><span class="line">    string s;</span><br><span class="line">    in &gt;&gt; s;</span><br><span class="line">    x = s.<span class="built_in">c_str</span>();  <span class="comment">//string转化为char[]</span></span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;out, <span class="type">const</span> bign &amp;x)&#123;  </span><br><span class="line"><span class="comment">//重载输出流</span></span><br><span class="line">    out &lt;&lt; x.<span class="built_in">str</span>();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Employ"><a href="#Employ" class="headerlink" title="Employ"></a>Employ</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bign a;<span class="comment">//声明高精度</span></span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">cout&lt;&lt;a;<span class="comment">//输入输出</span></span><br><span class="line">a=<span class="string">&quot;3333333333333333333333&quot;</span><span class="comment">//初始化    </span></span><br><span class="line"><span class="comment">//其余操作均和整数无异    </span></span><br></pre></td></tr></table></figure>

<h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><ol>
<li>该板子使用的时候需要关闭#define int long long</li>
<li>判断bign类型的数字与常规数字是否相等时，将常规数字转变为字符串类型后与bign.str()进行字符串比较</li>
</ol>
]]></content>
      <categories>
        <category>XCPC</category>
        <category>XCPC模板</category>
        <category>XCPC基础</category>
      </categories>
  </entry>
  <entry>
    <title>时间复杂度</title>
    <url>/2024/09/08/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%9F%BA%E7%A1%80/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>XCPC</tag>
        <tag>Tips</tag>
      </tags>
  </entry>
  <entry>
    <title>ST表</title>
    <url>/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ST%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="ST表基础封装"><a href="#ST表基础封装" class="headerlink" title="ST表基础封装"></a>ST表基础封装</h2><p>解决RMQ问题，不支持静态查询，预处理复杂度为O(nlog(n))，O(1)查询，常数比线段树小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ST</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; in1, in2, lg;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; Max, Min;</span><br><span class="line">    <span class="built_in">ST</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">in1</span>(n + <span class="number">1</span>), <span class="built_in">in2</span>(n + <span class="number">1</span>), <span class="built_in">lg</span>(n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            lg[i] = lg[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Max.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(lg[n] + <span class="number">1</span>));</span><br><span class="line">        Min.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(lg[n] + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Max[i][<span class="number">0</span>] = in1[i];</span><br><span class="line">            Min[i][<span class="number">0</span>] = in2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = lg[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">                Max[i][j] = <span class="built_in">max</span>(Max[i][j - <span class="number">1</span>], Max[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">                Min[i][j] = <span class="built_in">min</span>(Min[i][j - <span class="number">1</span>], Min[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = lg[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(Max[l][k], Max[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = lg[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(Min[l][k], Min[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>XCPC</category>
        <category>XCPC模板</category>
        <category>XCPC数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>哈希</title>
    <url>/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<h2 id="双哈希基础封装"><a href="#双哈希基础封装" class="headerlink" title="双哈希基础封装"></a>双哈希基础封装</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Shash</span>&#123;  </span><br><span class="line">    <span class="type">const</span> ll base[<span class="number">2</span>]=&#123;<span class="number">29</span>,<span class="number">31</span>&#125;;</span><br><span class="line">    <span class="comment">//base存储基数</span></span><br><span class="line">    <span class="type">const</span> ll hashmod[<span class="number">2</span>]=&#123;(ll)<span class="number">1e9</span><span class="number">+9</span>,<span class="number">998244353</span>&#125;;</span><br><span class="line">    <span class="comment">//hashmod存储模数</span></span><br><span class="line">    array&lt;vector&lt;ll&gt;,2&gt;hsh;</span><br><span class="line">    array&lt;vector&lt;ll&gt;,2&gt;pwMod;</span><br><span class="line">    <span class="comment">//hsh[2] 和 pwMod[2]：这两个二维 vector 分别用于存储哈希值和幂模值。</span></span><br><span class="line">    <span class="comment">//其中，hsh[i][j] 表示字符串前 j 个字符在基数 base[i] 和模数 hashmod[i] 下的哈希值；</span></span><br><span class="line">    <span class="comment">//pwMod[i][j] 表示基数 base[i] 的 j 次幂对 hashmod[i] 取模的结果。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(string S)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n=S.<span class="built_in">size</span>();S=<span class="string">&#x27; &#x27;</span>+S;</span><br><span class="line">        hsh[<span class="number">0</span>].<span class="built_in">resize</span>(n<span class="number">+1</span>),hsh[<span class="number">1</span>].<span class="built_in">resize</span>(n<span class="number">+1</span>);</span><br><span class="line">        pwMod[<span class="number">0</span>].<span class="built_in">resize</span>(n<span class="number">+1</span>),pwMod[<span class="number">1</span>].<span class="built_in">resize</span>(n<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)&#123;</span><br><span class="line">            pwMod[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">                pwMod[i][j]=pwMod[i][j<span class="number">-1</span>]*base[i]%hashmod[i];</span><br><span class="line">                hsh[i][j]=(hsh[i][j<span class="number">-1</span>]*base[i]+S[j])%hashmod[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get函数输出[l,r]这段字符的哈希值,first是第一个模数下哈希值,second是第二个</span></span><br><span class="line">    pair&lt;ll,ll&gt;<span class="built_in">get</span>(<span class="type">int</span> l,<span class="type">int</span> r)&#123;</span><br><span class="line">        pair&lt;ll,ll&gt; ans;</span><br><span class="line">        ans.first=(hsh[<span class="number">0</span>][r]-hsh[<span class="number">0</span>][l<span class="number">-1</span>]*pwMod[<span class="number">0</span>][r-l<span class="number">+1</span>])%hashmod[<span class="number">0</span>];</span><br><span class="line">        ans.second=(hsh[<span class="number">1</span>][r]-hsh[<span class="number">1</span>][l<span class="number">-1</span>]*pwMod[<span class="number">1</span>][r-l<span class="number">+1</span>])%hashmod[<span class="number">1</span>];</span><br><span class="line">        ans.first=(ans.first+hashmod[<span class="number">0</span>])%hashmod[<span class="number">0</span>];</span><br><span class="line">        ans.second=(ans.second+hashmod[<span class="number">1</span>])%hashmod[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(Shash &amp;a,<span class="type">int</span> la,<span class="type">int</span> ra,Shash &amp;b,<span class="type">int</span> lb,<span class="type">int</span> rb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">get</span>(la,ra)==b.<span class="built_in">get</span>(lb,rb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Employ"><a href="#Employ" class="headerlink" title="Employ"></a>Employ</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Shash a;</span><br><span class="line">a.<span class="built_in">init</span>(s)<span class="comment">//s是待处理字符串</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">same</span>(a,l,r,b,l,r))<span class="comment">//判断字符串a,b在l,r区间内是否相等</span></span><br><span class="line"><span class="comment">//该模板下标从1开始    </span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>XCPC</category>
        <category>XCPC模板</category>
        <category>XCPC数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="树状数组基础封装"><a href="#树状数组基础封装" class="headerlink" title="树状数组基础封装"></a>树状数组基础封装</h2><p> <strong>Fenwick Tree</strong> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;T&gt; tr;</span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">tr</span>(n + <span class="number">1</span>, <span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, T c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, T c)</span></span>&#123;</span><br><span class="line">        <span class="built_in">modify</span>(l, c);</span><br><span class="line">        <span class="keyword">if</span> (r + <span class="number">1</span> &lt;= n) <span class="built_in">modify</span>(r + <span class="number">1</span>, -c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        T res = <span class="built_in">T</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find_first</span><span class="params">(T sum)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>; T val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = __lg(n); i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((ans | (<span class="number">1</span> &lt;&lt; i)) &lt;= n &amp;&amp; val + tr[ans | (<span class="number">1</span> &lt;&lt; i)] &lt; sum)&#123;</span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                val += tr[ans];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find_last</span><span class="params">(T sum)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>; T val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = __lg(n); i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((ans | (<span class="number">1</span> &lt;&lt; i)) &lt;= n &amp;&amp; val + tr[ans | (<span class="number">1</span> &lt;&lt; i)] &lt;= sum)&#123;</span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                val += tr[ans];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> BIT = Fenwick&lt;<span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="Employ"><a href="#Employ" class="headerlink" title="Employ"></a>Employ</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">BIT <span class="title">tr</span><span class="params">(n)</span></span>;<span class="comment">//n是大小</span></span><br><span class="line"><span class="comment">//注意输入的时候要从1-n输入,vactor开n+1;</span></span><br><span class="line">tr.<span class="built_in">modify</span>(n,k)<span class="comment">//第n个数加上k</span></span><br><span class="line">tr.<span class="built_in">modify</span>(<span class="number">1</span>,n,k)<span class="comment">//从1到n每个数加k</span></span><br><span class="line">tr.<span class="built_in">query</span>(x)<span class="comment">//查询第x个数    </span></span><br><span class="line"><span class="comment">//三星提醒：初始化的时候是tr.modify(pos,pos,c),这样才代表只给pos位置赋值c</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>XCPC</category>
        <category>XCPC模板</category>
        <category>XCPC数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h2 id="并查集基础封装"><a href="#并查集基础封装" class="headerlink" title="并查集基础封装"></a>并查集基础封装</h2><p><strong>Disjoint Set Union</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; f,siz;</span><br><span class="line">    <span class="built_in">DSU</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        f.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        siz.<span class="built_in">assign</span>(n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x]) &#123;</span><br><span class="line">            x = f[x] = f[f[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        f[y] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> siz[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Employ"><a href="#Employ" class="headerlink" title="Employ"></a>Employ</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">DSU <span class="title">dsu</span><span class="params">(N)</span><span class="comment">//声明一个大小为N，名称为dsu的并查集</span></span></span><br><span class="line"><span class="function">dsu.<span class="title">merge</span><span class="params">(a,b)</span><span class="comment">//合并a,b</span></span></span><br><span class="line"><span class="function">dsu.<span class="title">find</span><span class="params">(x)</span><span class="comment">//找到x的祖宗节点</span></span></span><br><span class="line"><span class="function">dsu.size[dsu.<span class="title">find</span><span class="params">(x)</span>]<span class="comment">//以x为祖宗节点的个数 </span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>XCPC</category>
        <category>XCPC模板</category>
        <category>XCPC数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Dijkstra</title>
    <url>/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%9B%BE%E8%AE%BA/Dijkstra/</url>
    <content><![CDATA[<p>只介绍堆优化版的Dijikstra写法</p>
<span id="more"></span>

<h2 id="Dijikstra"><a href="#Dijikstra" class="headerlink" title="Dijikstra"></a>Dijikstra</h2><p>堆优化版本能在mlogn时间复杂度内求fi到se的最短路径(m为边,n为点)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> dijkstra=[&amp;](<span class="type">int</span> fi,<span class="type">int</span> se)&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dist</span>(n<span class="number">+10</span>,inf);</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt;<span class="built_in">st</span>(n<span class="number">+10</span>,<span class="literal">false</span>);</span><br><span class="line">        dist[fi] = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">        heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, fi&#125;);</span><br><span class="line">        <span class="keyword">while</span> (heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line">            <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">            st[ver] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i:g[ver])&#123;</span><br><span class="line">                <span class="type">int</span> j = i.first;</span><br><span class="line">                <span class="keyword">if</span> (dist[j] &gt; dist[ver] + i.second)&#123;</span><br><span class="line">                    dist[j] = dist[ver] + i.second;</span><br><span class="line">                    heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist[se];</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>XCPC</category>
        <category>XCPC模板</category>
        <category>XCPC图论</category>
      </categories>
  </entry>
  <entry>
    <title>连通性相关</title>
    <url>/2024/09/09/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%9B%BE%E8%AE%BA/%E8%BF%9E%E9%80%9A%E6%80%A7%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h2 id="割点与桥"><a href="#割点与桥" class="headerlink" title="割点与桥"></a>割点与桥</h2><h3 id="割点-cut-vertex-articulation-point）"><a href="#割点-cut-vertex-articulation-point）" class="headerlink" title="割点(cut vertex &#x2F; articulation point）"></a>割点(cut vertex &#x2F; articulation point）</h3><p>给出定义：删除该点后导致图不再连通的点称为割点</p>
<p>求割点的方法称为tarjan，在连通性相关的问题中广泛运用了该方法</p>
<p>tarjan的主要思想就是dfn与low数组</p>
<p>dfn：时间戳数组，dfn[i]称为节点i的dfs序</p>
<p>dfs序指的是在dfs过程中，该节点是第几个被访问到的节点。dfn数组的值随dfs过程单调上升。</p>
<p>low[i] 代表节点 i 在不直接返回父亲节点的情况下，通过“绕路”，能够访问到的节点里，最小的dfn值</p>
<p>由于割点与dfn数组的性质，不返回父亲节点的情况下，割点u的子结点中一定存在一点v使得dfn[u]&lt;&#x3D;low[v]</p>
<p>特别的，根节点的判断方法为子节点大于1</p>
<p>由于代码较为简单，割点代码不提供封装写法，有兴趣可以自行封装</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> dfs=[&amp;](<span class="keyword">auto</span> self,<span class="type">int</span> u,<span class="type">int</span> p)-&gt;<span class="type">void</span>&#123;</span><br><span class="line">        dfn[u]=low[u]=cur++;</span><br><span class="line">        <span class="type">int</span> son=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:g[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfn[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">                son++;</span><br><span class="line">                <span class="built_in">self</span>(self,i,u);</span><br><span class="line">                low[u]=<span class="built_in">min</span>(low[u],low[i]);</span><br><span class="line">                <span class="keyword">if</span>(p!=<span class="number">-1</span>&amp;&amp;low[i]&gt;=dfn[u])&#123;</span><br><span class="line">                    st[u]=<span class="number">1</span>;<span class="comment">//此时u为割点</span></span><br><span class="line">                    <span class="comment">//且每标记一次，共用该点的连通块数量就加1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i!=p)&#123;</span><br><span class="line">                low[u]=<span class="built_in">min</span>(low[u],dfn[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">-1</span>&amp;&amp;son&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            st[u]=<span class="number">1</span>;<span class="comment">//此时u为割点</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//根节点的共用连通块数量是son-1，求连通块时不必特判son&gt;1</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>



<h2 id="双连通分量-Biconnected-component"><a href="#双连通分量-Biconnected-component" class="headerlink" title="双连通分量 (Biconnected component)"></a>双连通分量 (Biconnected component)</h2><p>由于是双连通图，所以这部分讨论的均为无向图</p>
<h3 id="边双连通分量-EBC"><a href="#边双连通分量-EBC" class="headerlink" title="边双连通分量 (EBC)"></a>边双连通分量 (EBC)</h3><p>边双是Edge Biconnected Component，所以其实是EBCC，但是为了和割边缩点(EBCC)区别开，这里我们命名为EBC</p>
<p>给出定义：不存在割边&#x2F;桥的极大双连通子图称为边双连通分量</p>
<p>所以求边双的方法也很显然，将一张图中的所有割边&#x2F;桥断掉后，剩下的连通块均为一个边双，边双与边双之间以割边&#x2F;桥连接成一棵树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EBC</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;PII&gt;&gt;adj;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;dfn,low,stk;</span><br><span class="line">    <span class="type">int</span> cur,n;</span><br><span class="line">    <span class="built_in">EBC</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">EBC</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n=n;</span><br><span class="line">        adj.<span class="built_in">resize</span>(n,&#123;&#125;);</span><br><span class="line">        dfn.<span class="built_in">resize</span>(n,<span class="number">-1</span>);</span><br><span class="line">        low.<span class="built_in">resize</span>(n);</span><br><span class="line">        stk.<span class="built_in">clear</span>();</span><br><span class="line">        cur=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(&#123;v,i&lt;&lt;<span class="number">1</span>&#125;);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(&#123;u,i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        stk.<span class="built_in">push_back</span>(u);</span><br><span class="line">        dfn[u]=low[u]=cur++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:adj[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(i.second==(p^<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfn[i.first]==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i.first,i.second);</span><br><span class="line">                low[u]=<span class="built_in">min</span>(low[u],low[i.first]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low[u]=<span class="built_in">min</span>(low[u],dfn[i.first]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                y=stk.<span class="built_in">back</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(y);</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;<span class="keyword">while</span>(y!=u);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">work</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfn[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Employ"><a href="#Employ" class="headerlink" title="Employ"></a>Employ</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">EBC <span class="title">ebc</span><span class="params">(n<span class="number">+1</span>)</span></span>;<span class="comment">//建EBC</span></span><br><span class="line">ebc.<span class="built_in">edge</span>(u,v,i)<span class="comment">//i是for读入数据的i</span></span><br><span class="line"><span class="keyword">auto</span> ans=ebc.<span class="built_in">work</span>()<span class="comment">//ans数组存储每个双连通分量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:ans)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> j:i)&#123;</span><br><span class="line">        <span class="comment">//每个边双的点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="点双连通分量-VBC"><a href="#点双连通分量-VBC" class="headerlink" title="点双连通分量(VBC)"></a>点双连通分量(VBC)</h3>]]></content>
      <categories>
        <category>XCPC</category>
        <category>XCPC模板</category>
        <category>XCPC图论</category>
      </categories>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
