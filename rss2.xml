<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Chonu</title>
    <link>http://iokanux.com/</link>
    
    <atom:link href="http://iokanux.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Waiting You</description>
    <pubDate>Mon, 21 Oct 2024 08:12:26 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Codeforces Round 980 (Div2,A-D)</title>
      <link>http://iokanux.com/2024/10/21/XCPC/codeforces/Codeforces%20Round%20980%20(Div.%202)/</link>
      <guid>http://iokanux.com/2024/10/21/XCPC/codeforces/Codeforces%20Round%20980%20(Div.%202)/</guid>
      <pubDate>Mon, 21 Oct 2024 07:40:25 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;a href=&quot;https://mirror.codeforces.com/contest/2024/problem/A&quot;&gt;A - Profitable Interest Rate&lt;/a&gt;&lt;/p&gt;
&lt;figure clas</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><p><a href="https://mirror.codeforces.com/contest/2024/problem/A">A - Profitable Interest Rate</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;=b)&#123;</span><br><span class="line">        cout&lt;&lt;a&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">2</span>*a-b;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;k&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mirror.codeforces.com/contest/2024/problem/B">B - Buying Lemonade</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">   <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">   <span class="type">int</span> sum=<span class="number">0</span>,ans=<span class="number">0</span>,mn=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">      a[i]-=mn;</span><br><span class="line">      <span class="keyword">if</span>(sum+a[i]*(n-i)&lt;k)&#123;</span><br><span class="line">         sum+=a[i]*(n-i);</span><br><span class="line">         mn+=a[i];ans+=a[i]*(n-i);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         ans+=k-sum;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;  </span><br><span class="line">      ans++; </span><br><span class="line">   &#125;     </span><br><span class="line">   cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mirror.codeforces.com/contest/2024/problem/C">C - Concatenation of Arrays</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>,3&gt;&gt;<span class="built_in">a</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i][<span class="number">0</span>]&gt;&gt;a[i][<span class="number">1</span>];</span><br><span class="line">        a[i][<span class="number">2</span>]=a[i][<span class="number">0</span>]+a[i][<span class="number">1</span>];</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),[&amp;](<span class="keyword">auto</span> l,<span class="keyword">auto</span> r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[<span class="number">2</span>]!=r[<span class="number">2</span>])<span class="keyword">return</span> l[<span class="number">2</span>]&lt;r[<span class="number">2</span>]; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">min</span>(l[<span class="number">0</span>],l[<span class="number">1</span>])&lt;<span class="built_in">min</span>(r[<span class="number">0</span>],r[<span class="number">1</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;a[i][<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[i][<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mirror.codeforces.com/contest/2024/problem/D">D - Skipping</a></p><p>只有答题才能得分，所以跳题相当于花费a[i]从位置i转移到b[i]</p><p>答题就是花费0从i转移到i-1</p><p>最终答案就是所有能遍历到的位置上的a[i]-cost[i]</p><p>b[i]小于等于i时选择跳过是不明智的，因为此时在到达b[i]的过程中通过答题到b[i]能获得的分数一定更大</p><p>i 到 j 有两种方法，第一种是 j&#x3D;b[i]，直接从 i 跳到 j ；第二种是 i&lt;j&lt;b[i] ，从 i 跳到 b[i] 再向左答题到 j，两种方法的花费都是a[i]，</p><p>所以我们遍历所有位置，每次取能到当前位置且花费最小，转移到当前位置求每个能遍历到的位置的最小花费</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">   vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;<span class="built_in">a</span>(n<span class="number">+1</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].first;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].second;</span><br><span class="line">   priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt;pq;</span><br><span class="line">   pq.<span class="built_in">push</span>(&#123;a[<span class="number">1</span>].first,a[<span class="number">1</span>].second&#125;);</span><br><span class="line">   vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(n<span class="number">+1</span>,<span class="number">1e18</span>);</span><br><span class="line">   dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      <span class="keyword">while</span>(pq.<span class="built_in">size</span>()&amp;&amp;pq.<span class="built_in">top</span>().second&lt;i)&#123;</span><br><span class="line">         pq.<span class="built_in">pop</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      dp[i]=pq.<span class="built_in">top</span>().first;   </span><br><span class="line">      <span class="keyword">if</span>(a[i].second&gt;i)&#123;</span><br><span class="line">         pq.<span class="built_in">push</span>(&#123;dp[i]+a[i].first,a[i].second&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="type">int</span> sum=<span class="number">0</span>,ans=<span class="number">0</span>;          </span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">      sum+=a[i].first;</span><br><span class="line">      ans=<span class="built_in">max</span>(ans,sum-dp[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/Codeforces/">Codeforces</category>
      
      
      
      <comments>http://iokanux.com/2024/10/21/XCPC/codeforces/Codeforces%20Round%20980%20(Div.%202)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Codeforces Round 981 (Div3,A-F)</title>
      <link>http://iokanux.com/2024/10/21/XCPC/codeforces/Codeforces%20Round%20981%20(Div.%203)/</link>
      <guid>http://iokanux.com/2024/10/21/XCPC/codeforces/Codeforces%20Round%20981%20(Div.%203)/</guid>
      <pubDate>Mon, 21 Oct 2024 07:40:25 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;a href=&quot;https://mirror.codeforces.com/contest/2033/problem/A&quot;&gt;A - Sakurako and Kosuke&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;hi</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><p><a href="https://mirror.codeforces.com/contest/2033/problem/A">A - Sakurako and Kosuke</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> m=<span class="number">1</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            cnt-=(<span class="number">2</span>*i<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cnt+=(<span class="number">2</span>*i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(cnt)&lt;=n)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;            </span><br><span class="line">    cout&lt;&lt;(m&amp;<span class="number">1</span>?<span class="string">&quot;Kosuke&quot;</span>:<span class="string">&quot;Sakurako&quot;</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mirror.codeforces.com/contest/2033/problem/B"> B - Sakurako and Water</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">g</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>));</span><br><span class="line">    map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt;mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;g[i][j];</span><br><span class="line">            <span class="keyword">if</span>(g[i][j]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                mp[i-j].<span class="built_in">push_back</span>(<span class="built_in">abs</span>(g[i][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[x,y]:mp)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(y.<span class="built_in">begin</span>(),y.<span class="built_in">end</span>(),<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        ans+=y[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mirror.codeforces.com/contest/2033/problem/C">C - Sakurako’s Field Trip</a></p><p>C这个题有一点说法，其实想明白什么时候换就可以</p><p>从左到n&#x2F;2的位置每次考虑是否交换当前位置，当i这个位置与i-1的数相同的时候或者n-i+1与其下一个数（就是当前数与其遍历过的上一个数）相同的时候选择交换，可以证明这样操作对答案的增益一定是非负的</p><p>证明如下</p><ol><li><p>如果a[i]&#x3D;&#x3D;a[n-i+1]，操作无影响</p></li><li><p>a[i]!&#x3D;a[n-i+1]，</p><p>设交换之前点i对答案的增益为 ans&#x3D;(a[i]&#x3D;&#x3D;a[i-1]+a[i]&#x3D;&#x3D;a[i+1]+a[n-i+1]&#x3D;&#x3D;a[n-i]+a[n-i+1]&#x3D;&#x3D;a[n-i+2])</p><p>交换之后点i对答案的增益为 ans1&#x3D;(a[n-i+1]&#x3D;&#x3D;a[i-1]+a[n-i+1]&#x3D;&#x3D;a[i+1]+a[i]&#x3D;&#x3D;a[n-i]+a[i]&#x3D;&#x3D;a[n-i+2])</p><p>最坏情况就是</p><p>a[i]&#x3D;&#x3D;a[i-1]&amp;&amp;a[i]!&#x3D;a[i+1]&amp;&amp;a[n-i+1]!&#x3D;a[n-i]&amp;&amp;a[n-i+1]!&#x3D;a[n-i+2]</p><p>a[n-i+1]&#x3D;&#x3D;a[i+1]&amp;&amp;a[i]&#x3D;&#x3D;a[n-i]&amp;&amp;a[i]&#x3D;&#x3D;a[n-i+2]</p><p>这样的话，交换之后答案多2，但是这种情况下在下一次交换过程中会被重新满足条件执行交换</p></li></ol><p>综上，一直执行交换，最后求答案即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n<span class="number">+10</span>,<span class="number">0</span>),<span class="built_in">cnt</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=(n<span class="number">+1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>]||a[n-i<span class="number">+1</span>]==a[n-i<span class="number">+2</span>])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i],a[n-i<span class="number">+1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[i<span class="number">+1</span>]) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mirror.codeforces.com/contest/2033/problem/D">D - Kousuke’s Assignment</a></p><p>没啥说的，遇到0就断开一定是最优的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n<span class="number">+1</span>),<span class="built_in">pre</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,lst=<span class="number">0</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            lst=i;ans++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> d=pre[i]-pre[lst];</span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">0</span>)&#123; </span><br><span class="line">            <span class="keyword">if</span>(lst&lt;i)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                lst=<span class="built_in">max</span>(i,lst);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mp.<span class="built_in">count</span>(d))&#123;</span><br><span class="line">            <span class="keyword">if</span>(lst&lt;mp[d])&#123;</span><br><span class="line">                 ans++;</span><br><span class="line">                lst=<span class="built_in">max</span>(i,lst);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mp[d]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mirror.codeforces.com/contest/2033/problem/E">E - Sakurako, Kosuke, and the Permutation</a></p><p>每次交换完之后就保证当前位置不再交换,这样顺序从1到n就是最小交换次数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">     vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n<span class="number">+1</span>),<span class="built_in">pos</span>(n<span class="number">+1</span>);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        pos[a[i]]=i;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(a[i]==i) <span class="keyword">continue</span>;</span><br><span class="line">         <span class="keyword">if</span>(pos[i]==a[i]&amp;&amp;a[a[i]]==i) <span class="keyword">continue</span>;</span><br><span class="line">         <span class="built_in">swap</span>(a[pos[i]],a[a[i]]);</span><br><span class="line">         <span class="built_in">swap</span>(pos[a[pos[i]]],pos[a[a[i]]]);</span><br><span class="line">         ans++;</span><br><span class="line">     &#125;</span><br><span class="line">     cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mirror.codeforces.com/contest/2033/problem/F">F - Kosuke’s Sloth</a></p><p>递推数列具有模周期性，找到第一个循环节中的下标再乘n即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">f[<span class="number">1</span>]=f[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=<span class="number">3</span>) f[i]=(f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>])%k;</span><br><span class="line"><span class="keyword">if</span>(f[i]%k==<span class="number">0</span>)&#123;</span><br><span class="line">pos=i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;(pos%mod)*(n%mod)%mod&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/Codeforces/">Codeforces</category>
      
      
      
      <comments>http://iokanux.com/2024/10/21/XCPC/codeforces/Codeforces%20Round%20981%20(Div.%203)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Educational Codeforces Round 170 (Rated for Div.2)</title>
      <link>http://iokanux.com/2024/10/15/XCPC/codeforces/Educational%20Codeforces%20Round%20170%20(Rated%20for%20Div.%202)/</link>
      <guid>http://iokanux.com/2024/10/15/XCPC/codeforces/Educational%20Codeforces%20Round%20170%20(Rated%20for%20Div.%202)/</guid>
      <pubDate>Tue, 15 Oct 2024 06:53:25 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;D-Attribute-Checks&quot;&gt;&lt;a href=&quot;#D-Attribute-Checks&quot; class=&quot;headerlink&quot; title=&quot;D - Attribute Checks&quot;&gt;&lt;/a&gt;&lt;a hr</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h1 id="D-Attribute-Checks"><a href="#D-Attribute-Checks" class="headerlink" title="D - Attribute Checks"></a><a href="https://mirror.codeforces.com/contest/2025/problem/D">D - Attribute Checks</a></h1><p>$设&gt;0为s技能点,小于0为t技能点$</p><p>$dp[i][j]$表示前i个位置加了j个s技能点,自然在前i个位置加了i*m-j个t技能点</p>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/Codeforces/">Codeforces</category>
      
      
      <category domain="http://iokanux.com/tags/dp/">dp</category>
      
      
      <comments>http://iokanux.com/2024/10/15/XCPC/codeforces/Educational%20Codeforces%20Round%20170%20(Rated%20for%20Div.%202)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2023ICPC网络赛(一)</title>
      <link>http://iokanux.com/2024/09/13/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/2023ICPC%E7%BD%91%E7%BB%9C%E8%B5%9B(%E4%B8%80)/</link>
      <guid>http://iokanux.com/2024/09/13/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/2023ICPC%E7%BD%91%E7%BB%9C%E8%B5%9B(%E4%B8%80)/</guid>
      <pubDate>Fri, 13 Sep 2024 13:10:33 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;D-Transitivity&quot;&gt;&lt;a href=&quot;#D-Transitivity&quot; class=&quot;headerlink&quot; title=&quot;D. Transitivity&quot;&gt;&lt;/a&gt;D. Transitivity&lt;/h</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h2 id="D-Transitivity"><a href="#D-Transitivity" class="headerlink" title="D. Transitivity"></a>D. Transitivity</h2><p>Given a <strong>simple undirected graph</strong> with $n$ vertices and $m$ edges, and it’s guaranteed that</p><p>We define an undirected graph to be transitive if and only if for any two <strong>different</strong> vertices $u, v$ :</p><p>If there exists a path starting from $u$ and ending at $v$ in the graph, then there should exists an edge connected $u$ and $v$ in the graph.</p><p>Now you should add some undirected edges to the graph (<strong>add at least one edge</strong>). You need to ensure that after adding edges, the graph is still a simple undirected graph and is transitive.</p><p>The question is, how many edges need to be added at least?</p><p>Recall that a simple undirected graph is an undirected graph that does not have more than one edge between any two vertices and no edge starts and ends at the same vertex.</p><p>$n_{k}^9$</p>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/">XCPC系列赛</category>
      
      
      
      <comments>http://iokanux.com/2024/09/13/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/2023ICPC%E7%BD%91%E7%BB%9C%E8%B5%9B(%E4%B8%80)/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2024CCPC网络赛</title>
      <link>http://iokanux.com/2024/09/12/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/2024CCPC%E7%BD%91%E7%BB%9C%E8%B5%9B/</link>
      <guid>http://iokanux.com/2024/09/12/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/2024CCPC%E7%BD%91%E7%BB%9C%E8%B5%9B/</guid>
      <pubDate>Thu, 12 Sep 2024 11:03:33 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;B-军训-II&quot;&gt;&lt;a href=&quot;#B-军训-II&quot; class=&quot;headerlink&quot; title=&quot;B 军训 II&quot;&gt;&lt;/a&gt;B 军训 II&lt;/h2&gt;&lt;p&gt;对于这类问题一个很经典的思路就是求每个位置的贡献&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h2 id="B-军训-II"><a href="#B-军训-II" class="headerlink" title="B 军训 II"></a>B 军训 II</h2><p>对于这类问题一个很经典的思路就是求每个位置的贡献</p><p>首先能感性的判断出来从小到大&#x2F;从大到小排不整齐度是最小的(因为最大&#x2F;最小值都是依次递增的)</p><p>然后可以理性的证明一下：</p><p>对于已经排好序的数组a 有a1&lt;&#x3D;a2&lt;&#x3D;a3&lt;&#x3D;…&lt;&#x3D;an,此时交换a2,ak(假设a2&lt;ak);</p><p>交换完的结果就是l在[1,k-1],r在[l,k-1]的区间内最大值变大，最小值不变,l在[k,n]，r在[l,n]的区间内最大值不变，最小值变小</p><p>身高相同的人可以交换位置,$A_{k}^k$,表示k个身高相同的人的排列方案,</p><p>注意特判全相等序列(从小到大和从大到小排列一样)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n);</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];mp[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">            ans1+=a[j]-a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> A=[&amp;](<span class="type">int</span> x)&#123;</span><br><span class="line">        <span class="type">int</span> tem=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)&#123;</span><br><span class="line">            tem=(tem*i)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tem;</span><br><span class="line">    &#125;;</span><br><span class="line">    a.<span class="built_in">erase</span>(<span class="built_in">unique</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:a)&#123;</span><br><span class="line">        ans2=(ans2*<span class="built_in">A</span>(mp[i]))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()!=<span class="number">1</span>) ans2=(ans2*<span class="number">2</span>)%mod;</span><br><span class="line">    cout&lt;&lt;ans1&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ans2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-取沙子游戏"><a href="#K-取沙子游戏" class="headerlink" title="K 取沙子游戏"></a>K 取沙子游戏</h2><p>考虑n的奇偶性</p><p>当n为奇数时，第一手取1必然获胜</p><p>当n为偶数时，考虑变成必胜态，即将n减去某两个数得到奇数，可知这两个数必然为一奇一偶，且先手必选偶数，当先手选择奇数后，后手必胜。</p><p>由于选择的是偶数，初步猜想寄了，因为后手必然不会选择奇数，所以后手选择偶数阻止先手到达必胜态，此时第二轮到达先手手上的数还是偶数，这样归纳一下可以发现当n为偶数的时候，先后手都只会选择偶数</p><p>考虑二进制，当先手第一次选择lowbit(n)时，后手无论选择什么我们都和其选择一样即可获胜，因为二进制下需要偶数次选择偶数才能将这个数归零</p>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/">XCPC系列赛</category>
      
      
      
      <comments>http://iokanux.com/2024/09/12/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/2024CCPC%E7%BD%91%E7%BB%9C%E8%B5%9B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ICPC·2020·小米网络赛二</title>
      <link>http://iokanux.com/2024/09/11/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/ICPC%C2%B72020%C2%B7%E5%B0%8F%E7%B1%B3%E7%BD%91%E7%BB%9C%E8%B5%9B%E4%BA%8C/</link>
      <guid>http://iokanux.com/2024/09/11/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/ICPC%C2%B72020%C2%B7%E5%B0%8F%E7%B1%B3%E7%BD%91%E7%BB%9C%E8%B5%9B%E4%BA%8C/</guid>
      <pubDate>Wed, 11 Sep 2024 10:55:39 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;G-Shift-and-Reverse&quot;&gt;&lt;a href=&quot;#G-Shift-and-Reverse&quot; class=&quot;headerlink&quot; title=&quot;G Shift and Reverse&quot;&gt;&lt;/a&gt;G Sh</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h2 id="G-Shift-and-Reverse"><a href="#G-Shift-and-Reverse" class="headerlink" title="G Shift and Reverse"></a>G Shift and Reverse</h2><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>Bobo has a sequence $a_1,a_2,\dots,a_n$. He can rearrange the sequence using the following operation any number of times:  </p><p>+ Select an integer i ($1 \le i \le n$) and change the sequence to $a_i, a_{i-1}, \dots, a_1, a_n, a_{n-1}, \dots, a_{i+1}$.  </p><p>Bobo would like to know the number of different sequences can be obtained modulo $(10^9+7)$.</p><p>波波有一个序列$a_1,a_2,\dots,a_n$。他可以使用以下操作任意次数重新排列序列:</p><p>选择整数i($1 \le i \le n$)并将序列更改为$a_i, a_{i-1}, \dots, a_1, a_n, a_{n-1}, \dots, a_{i+1}$。</p><p>Bobo想知道有多少个不同的序列对$(10^9+7)$取模。</p><h3 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse"></a>Analyse</h3><p>遇到题目没思路就先模拟一下</p><p>一个新的数组a,标号从a1-an,假定选择k进行反转操作，执行操作后的序列为$a_{k},a_{k-1}…a_{k+2},a_{k+1},$</p>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/">XCPC系列赛</category>
      
      
      
      <comments>http://iokanux.com/2024/09/11/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/ICPC%C2%B72020%C2%B7%E5%B0%8F%E7%B1%B3%E7%BD%91%E7%BB%9C%E8%B5%9B%E4%BA%8C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>子序列相关</title>
      <link>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <guid>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <pubDate>Wed, 11 Sep 2024 05:40:25 GMT</pubDate>
      
      <description>&lt;p&gt;动态规划中的子序列问题&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>动态规划中的子序列问题</p><span id="more"></span><p>子序列(subsequence)不要求连续，但相对顺序不能改变</p><h2 id="最长上升子序列-LIS"><a href="#最长上升子序列-LIS" class="headerlink" title="最长上升子序列(LIS)"></a>最长上升子序列(LIS)</h2><p>Longest Increasing Subsequence</p><h3 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i]表示以num[i]结尾的最长上升子序列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    dp[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[j]&lt;num[i])&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i],dp[j]<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="O-nlogn"><a href="#O-nlogn" class="headerlink" title="O(nlogn)"></a>O(nlogn)</h3><p>二分法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;stk;<span class="comment">//模拟堆栈</span></span><br><span class="line">    stk.<span class="built_in">push_back</span>(a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;stk.<span class="built_in">back</span>())&#123;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            *<span class="built_in">lower_bound</span>(stk.<span class="built_in">begin</span>(),stk.<span class="built_in">end</span>(),a[i])=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//stk.size()为LIS长度</span></span><br></pre></td></tr></table></figure><h2 id="最长下降子序列-LDS"><a href="#最长下降子序列-LDS" class="headerlink" title="最长下降子序列(LDS)"></a>最长下降子序列(LDS)</h2><p>Longest Decreasing Subsequence,反方向的LIS</p><h3 id="O-nlogn-1"><a href="#O-nlogn-1" class="headerlink" title="O(nlogn)"></a>O(nlogn)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;stk;<span class="comment">//模拟堆栈</span></span><br><span class="line">    stk.<span class="built_in">push_back</span>(a[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;stk.<span class="built_in">back</span>())&#123;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            *<span class="built_in">lower_bound</span>(stk.<span class="built_in">begin</span>(),stk.<span class="built_in">end</span>(),a[i])=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="最长不上升子序列-LNIS"><a href="#最长不上升子序列-LNIS" class="headerlink" title="最长不上升子序列(LNIS)"></a>最长不上升子序列(LNIS)</h2><p>Longest Non-increasing Subsequence</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stk.<span class="built_in">push_back</span>(a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=stk.<span class="built_in">back</span>())&#123;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            *<span class="built_in">upper_bound</span>(stk.<span class="built_in">begin</span>(),stk.<span class="built_in">end</span>(),a[i],<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;())=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h2><p>Longest Common Subsequence</p><h3 id="O-nm"><a href="#O-nm" class="headerlink" title="O(nm)"></a>O(nm)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        dp[i][j]=<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">        <span class="keyword">if</span>(s[i]==t[j])&#123;</span><br><span class="line">           dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="O-nlogm"><a href="#O-nlogm" class="headerlink" title="O(nlogm)"></a>O(nlogm)</h3><p>一般情况下时间复杂度为O(nlogm)，但是最坏可退化至O(nm)</p><p>具体就是将LCS问题转化为LIS问题来做</p>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/">XCPC模板</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">XCPC动态规划</category>
      
      
      
      <comments>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>XCPC杂项</title>
      <link>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC/XCPC%E5%9F%BA%E7%A1%80/</link>
      <guid>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC/XCPC%E5%9F%BA%E7%A1%80/</guid>
      <pubDate>Wed, 11 Sep 2024 05:40:25 GMT</pubDate>
      
      <description>&lt;p&gt;介绍XCPC赛事中的杂项知识点&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>介绍XCPC赛事中的杂项知识点</p><span id="more"></span><h1 id="XCPC-基础"><a href="#XCPC-基础" class="headerlink" title="XCPC 基础"></a>XCPC 基础</h1><h2 id="对拍板子"><a href="#对拍板子" class="headerlink" title="对拍板子"></a>对拍板子</h2><p>介绍Windows环境下与Linux环境下的对拍</p><p>对拍去DEV</p><h3 id="Windows环境"><a href="#Windows环境" class="headerlink" title="Windows环境"></a>Windows环境</h3><p>以DEV为例，首先建四个源代码到一个新建文件夹中，源代码分别命名为wa.cpp,data.cpp,violent.cpp,windows.cpp,除此之外什么也不需要添加</p><ol><li>一份错误的&#x2F;需要比对的代码，导入wa.cpp</li><li>一份暴力的&#x2F;用来比对的代码，导入violent.cpp</li><li>一份用来造数据的代码</li><li>一份执行对拍程序的代码</li></ol><h4 id="wa-cpp"><a href="#wa-cpp" class="headerlink" title="wa.cpp"></a>wa.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin); <span class="comment">//读入数据生成器造出来的数据</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;wa.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout); <span class="comment">//输出答案</span></span><br><span class="line"><span class="comment">//下方注释为你的程序</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">int a, b;</span></span><br><span class="line"><span class="comment">cin &gt;&gt; a &gt;&gt; b;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; a;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="violent-cpp"><a href="#violent-cpp" class="headerlink" title="violent.cpp"></a>violent.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);      <span class="comment">//读入数据生成器造出来的数据</span></span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;violent.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout); <span class="comment">//输出答案</span></span><br><span class="line"><span class="comment">//下方程序为你已经导入的程序</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">int a, b;</span></span><br><span class="line"><span class="comment">cin &gt;&gt; a &gt;&gt; b;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; a + b;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="data-cpp"><a href="#data-cpp" class="headerlink" title="data.cpp"></a>data.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_timeb</span> T;</span><br><span class="line">_ftime(&amp;T);</span><br><span class="line"><span class="built_in">srand</span>(T.millitm); <span class="comment">//获得毫秒，减小运行时间</span></span><br><span class="line"><span class="type">int</span> a = <span class="built_in">rand</span>(); <span class="comment">//此时a是一个随机数字</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="windows-cpp"><a href="#windows-cpp" class="headerlink" title="windows.cpp"></a>windows.cpp</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">//一直循环，直到找到不一样的数据</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;data.exe&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;violent.exe&quot;</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;wa.exe&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">system</span>(<span class="string">&quot;fc wa.txt violent.txt&quot;</span>)) <span class="comment">//当 fc 返回 1 时，说明这时数据不一样</span></span><br><span class="line"><span class="keyword">break</span>;                          <span class="comment">//不一样就跳出循环</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，以上所有程序均需要编译并运行</strong></p><h2 id="前缀和-Prefix-Sum"><a href="#前缀和-Prefix-Sum" class="headerlink" title="前缀和(Prefix Sum)"></a>前缀和(Prefix Sum)</h2><p>通过构建前缀和数组，从而能做到O(1)时间复杂度的区间查询(rangeQuery)</p><h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><h4 id="构建前缀和数组"><a href="#构建前缀和数组" class="headerlink" title="构建前缀和数组"></a>构建前缀和数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">pre</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pre[i]=pre[i<span class="number">-1</span>]+a[i];</span><br></pre></td></tr></table></figure><h4 id="rangeQuery"><a href="#rangeQuery" class="headerlink" title="rangeQuery"></a>rangeQuery</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre[r]-pre[l<span class="number">-1</span>]<span class="comment">//求(l,r)区间和</span></span><br></pre></td></tr></table></figure><h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><h4 id="构建前缀和数组-1"><a href="#构建前缀和数组-1" class="headerlink" title="构建前缀和数组"></a>构建前缀和数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">pre</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        pre[i][j]=pre[i<span class="number">-1</span>][j]+pre[i][j<span class="number">-1</span>]-pre[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">        <span class="comment">//pre[i][j]表示(1,1)为左上角,(i,j)为右下角的矩阵的和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rangeQuery-1"><a href="#rangeQuery-1" class="headerlink" title="rangeQuery"></a>rangeQuery</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pre[x2][y2]-pre[x2][y1<span class="number">-1</span>]-pre[x1<span class="number">-1</span>][y2]+pre[x1<span class="number">-1</span>][y1<span class="number">-1</span>];</span><br><span class="line"><span class="comment">//求左上角为(x1,y1)，右下角为(x2,y2)的矩阵和    </span></span><br></pre></td></tr></table></figure><h2 id="差分-Difference"><a href="#差分-Difference" class="headerlink" title="差分(Difference)"></a>差分(Difference)</h2><p>通过构建差分数组，从而能做到O(1)时间复杂度的区间修改(rangeModify)</p><h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><ol><li>单点修改，单点询问</li></ol><p>构建差分数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">dif</span>(n<span class="number">+5</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dif[i]=a[i]-a[i<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><p>rangeModify</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dif[l]+=k;dif[r<span class="number">+1</span>]-=k;<span class="comment">//(l,r)区间每个数都加k</span></span><br></pre></td></tr></table></figure><p>Query</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i]+=b[i<span class="number">-1</span>];<span class="comment">//此时b[i]就是修改完后的第i个数的值</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>单点修改，区间询问</p><p>具体就是构建两个差分数组，每次单点修改的左端加1，右端也加1，全部操作执行完求前缀和,区间询问[l,r]的时候相减即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">L</span>(n<span class="number">+10</span>),<span class="built_in">R</span>(n<span class="number">+10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">    <span class="type">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">    L[u]++;R[v]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    L[i]+=L[i<span class="number">-1</span>];</span><br><span class="line">    R[i]+=R[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">    <span class="type">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    cout&lt;&lt;R[r]-L[l<span class="number">-1</span>]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p>与一维差分不同的是，二维差分数组的构建与修改均可以通过差分函数来完成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dif</span>(n<span class="number">+5</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+5</span>));</span><br><span class="line"><span class="keyword">auto</span> modify=[&amp;](<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> x)&#123;</span><br><span class="line">    dif[x1][y1]+=x;</span><br><span class="line">    dif[x1][y2<span class="number">+1</span>]-=x;</span><br><span class="line">    dif[x2<span class="number">+1</span>][y1]-=x;</span><br><span class="line">    dif[x2<span class="number">+1</span>][y2<span class="number">+1</span>]+=x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="构建差分数组"><a href="#构建差分数组" class="headerlink" title="构建差分数组"></a>构建差分数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        <span class="built_in">modify</span>(i,j,i,j,a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rangeModify"><a href="#rangeModify" class="headerlink" title="rangeModify"></a>rangeModify</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">modify</span>(x1,y1,x2,y2,x);<span class="comment">//对左上角为(x1,y1),右下角为(x2,y2)的矩阵每个数都加上x</span></span><br></pre></td></tr></table></figure><h4 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h4><p>前缀和求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        dif[i][j]+=dif[i<span class="number">-1</span>][j]+dif[i][j<span class="number">-1</span>]-dif[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">//pre[i][j]表示(1,1)为左上角,(i,j)为右下角的矩阵的和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="间隔差分"><a href="#间隔差分" class="headerlink" title="间隔差分"></a>间隔差分</h3><p>[l,r]中间隔k个数字修改，其中r&#x3D;l + k * n, 相当于[l,l+k,l+2 * k,… l + n * k]这么多数修改</p><p>构建差分数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre[l]++;pre[r]--;<span class="comment">//注意此时一定是最右侧的点进行减，不是最右边减一</span></span><br></pre></td></tr></table></figure><p>求和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sum;i++)<span class="comment">//sum为整个数组大范围,写成这样，即使多次修改区间也能在一次遍历的时间里算完</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;=sum;i++)&#123;</span><br><span class="line">​pre[i]+=pre[i-k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5005</span>;<span class="comment">//位数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bign</span>&#123;</span><br><span class="line">    <span class="type">int</span> len, s[MAXN];</span><br><span class="line">    <span class="built_in">bign</span> ()&#123;  </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in">sizeof</span>(s));</span><br><span class="line">        len = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bign</span> (<span class="type">int</span> num) &#123; *<span class="keyword">this</span> = num; &#125;</span><br><span class="line">    <span class="built_in">bign</span> (<span class="type">const</span> <span class="type">char</span> *num) &#123; *<span class="keyword">this</span> = num; &#125;  <span class="comment">//让this指针指向当前字符串</span></span><br><span class="line">    bign <span class="keyword">operator</span> = (<span class="type">const</span> <span class="type">int</span> num)&#123;</span><br><span class="line">        <span class="type">char</span> s[MAXN];</span><br><span class="line">        <span class="built_in">sprintf</span>(s, <span class="string">&quot;%d&quot;</span>, num);  <span class="comment">//sprintf函数将整型映到字符串中</span></span><br><span class="line">        *<span class="keyword">this</span> = s;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">//再将字符串转到下面字符串转化的函数中</span></span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> = (<span class="type">const</span> <span class="type">char</span> *num)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; num[i] == <span class="string">&#x27;0&#x27;</span>; num++) ;  <span class="comment">//去前导0</span></span><br><span class="line">        len = <span class="built_in">strlen</span>(num);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) s[i] = num[len-i<span class="number">-1</span>] - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//反着存</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> + (<span class="type">const</span> bign &amp;b) <span class="type">const</span>&#123; </span><br><span class="line">    <span class="comment">//对应位相加，最为简单</span></span><br><span class="line">        bign c;</span><br><span class="line">        c.len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, g = <span class="number">0</span>; g || i &lt; <span class="built_in">max</span>(len, b.len); i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = g;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; len) x += s[i];</span><br><span class="line">            <span class="keyword">if</span>(i &lt; b.len) x += b.s[i];</span><br><span class="line">            c.s[c.len++] = x % <span class="number">10</span>;  <span class="comment">//关于加法进位</span></span><br><span class="line">            g = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> += (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        <span class="comment">//如上文所说，此类运算符皆如此重载</span></span><br><span class="line">        *<span class="keyword">this</span> = *<span class="keyword">this</span> + b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clean</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="comment">//由于接下来的运算不能确定结果的长度，先大而估之然后再查</span></span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">1</span> &amp;&amp; !s[len<span class="number">-1</span>]) len--;  <span class="comment">//首位部分‘0’故删除该部分长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> * (<span class="type">const</span> bign &amp;b)&#123; </span><br><span class="line">    <span class="comment">//乘法重载在于列竖式，再将竖式中的数转为抽象，即可看出运算法则。</span></span><br><span class="line">        bign c;</span><br><span class="line">        c.len = len + b.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; b.len; j++)&#123;</span><br><span class="line">                c.s[i+j] += s[i] * b.s[j];<span class="comment">//不妨列个竖式看一看</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.len; i++)&#123; </span><br><span class="line">            <span class="comment">//关于进位，与加法意同</span></span><br><span class="line">            c.s[i<span class="number">+1</span>] += c.s[i]/<span class="number">10</span>;</span><br><span class="line">            c.s[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c.<span class="built_in">clean</span>();  <span class="comment">//我们估的位数是a+b的长度和，但可能比它小（1*1 = 1）</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> *= (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        *<span class="keyword">this</span> = *<span class="keyword">this</span> * b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> - (<span class="type">const</span> bign &amp;b)&#123;  </span><br><span class="line">    <span class="comment">//对应位相减，加法的进位改为借1</span></span><br><span class="line">        <span class="comment">//不考虑负数</span></span><br><span class="line">        bign c;</span><br><span class="line">        c.len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, g = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = s[i] - g;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; b.len) x -= b.s[i];  <span class="comment">//可能长度不等</span></span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span>) g = <span class="number">0</span>;  <span class="comment">//是否向上移位借1</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                g = <span class="number">1</span>;</span><br><span class="line">                x += <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            c.s[c.len++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        c.<span class="built_in">clean</span>();</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> -= (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        *<span class="keyword">this</span> = *<span class="keyword">this</span> - b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> / (<span class="type">const</span> bign &amp;b) &#123;</span><br><span class="line">    <span class="comment">//运用除是减的本质，不停地减，直到小于被减数</span></span><br><span class="line">        bign c, f = <span class="number">0</span>; <span class="comment">//可能会在使用减法时出现高精度运算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;  </span><br><span class="line">            <span class="comment">//正常顺序，从最高位开始</span></span><br><span class="line">            f = f*<span class="number">10</span>;  <span class="comment">//上面位的剩余到下一位*10</span></span><br><span class="line">            f.s[<span class="number">0</span>] = s[i];  <span class="comment">//加上当前位</span></span><br><span class="line">            <span class="keyword">while</span>(f &gt;= b)&#123;</span><br><span class="line">                f -= b;</span><br><span class="line">                c.s[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c.len = len;  <span class="comment">//估最长位</span></span><br><span class="line">        c.<span class="built_in">clean</span>();</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> /= (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        *<span class="keyword">this</span>  = *<span class="keyword">this</span> / b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> % (<span class="type">const</span> bign &amp;b)&#123;  </span><br><span class="line">    <span class="comment">//取模就是除完剩下的</span></span><br><span class="line">        bign r = *<span class="keyword">this</span> / b;</span><br><span class="line">        r = *<span class="keyword">this</span> - r*b;</span><br><span class="line">        r.<span class="built_in">clean</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span> %= (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        *<span class="keyword">this</span> = *<span class="keyword">this</span> % b;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> bign &amp;b)&#123; </span><br><span class="line">    <span class="comment">//字符串比较原理</span></span><br><span class="line">        <span class="keyword">if</span>(len != b.len) <span class="keyword">return</span> len &lt; b.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len<span class="number">-1</span>; i != <span class="number">-1</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != b.s[i]) <span class="keyword">return</span> s[i] &lt; b.s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &gt; (<span class="type">const</span> bign &amp;b)&#123;  </span><br><span class="line">    <span class="comment">//同理</span></span><br><span class="line">        <span class="keyword">if</span>(len != b.len) <span class="keyword">return</span> len &gt; b.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len<span class="number">-1</span>; i != <span class="number">-1</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != b.s[i]) <span class="keyword">return</span> s[i] &gt; b.s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> &gt; b) &amp;&amp; !(*<span class="keyword">this</span> &lt; b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> == b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;= (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> &lt; b || *<span class="keyword">this</span> == b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &gt;= (<span class="type">const</span> bign &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> &gt; b || *<span class="keyword">this</span> == b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">()</span> <span class="type">const</span></span>&#123;  </span><br><span class="line">    <span class="comment">//将结果转化为字符串（用于输出）</span></span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) res = <span class="built_in">char</span>(s[i]+<span class="string">&#x27;0&#x27;</span>)+res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream &amp;in, bign &amp;x)&#123;</span><br><span class="line"><span class="comment">//重载输入流</span></span><br><span class="line">    string s;</span><br><span class="line">    in &gt;&gt; s;</span><br><span class="line">    x = s.<span class="built_in">c_str</span>();  <span class="comment">//string转化为char[]</span></span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream &amp;out, <span class="type">const</span> bign &amp;x)&#123;  </span><br><span class="line"><span class="comment">//重载输出流</span></span><br><span class="line">    out &lt;&lt; x.<span class="built_in">str</span>();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bign a;<span class="comment">//除了声明外其他如整型般使用</span></span><br><span class="line">    a=<span class="string">&quot;333333333333333333333333333&quot;</span>;</span><br><span class="line">    cout&lt;&lt;a*a&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="sqrt"><a href="#sqrt" class="headerlink" title="sqrt"></a>sqrt</h3><p>对long long使用sqrt，类型转换为long double</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=(<span class="type">long</span> <span class="type">double</span>)<span class="built_in">sqrt</span>(x);<span class="comment">//x为long long类型</span></span><br></pre></td></tr></table></figure><h3 id="pdbs"><a href="#pdbs" class="headerlink" title="pdbs"></a>pdbs</h3><p>头文件及命名空间，注意编译器开g++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/extc++.h&gt;</span> <span class="comment">//类似万能头，包含大多扩展库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_pbds;</span><br></pre></td></tr></table></figure><h4 id="堆-优先队列"><a href="#堆-优先队列" class="headerlink" title="堆(优先队列)"></a>堆(优先队列)</h4><h3 id="防卡unordered-map"><a href="#防卡unordered-map" class="headerlink" title="防卡unordered_map"></a>防卡unordered_map</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">mp.<span class="built_in">reserve</span>(<span class="number">1024</span>);</span><br><span class="line">mp.<span class="built_in">max_load_factor</span>(<span class="number">0.25</span>);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.f</span>ind（str，pos）<span class="comment">//找到的返回下标，找不到返回string：：npos</span></span><br><span class="line"><span class="number">2.</span>count<span class="comment">//（起始位，终止位，目标物）</span></span><br><span class="line"><span class="number">3.</span><span class="built_in">getline</span>(cin,s)<span class="comment">//整行读入，并将结果存储在字符串s里面</span></span><br><span class="line"><span class="number">4.</span>s.<span class="built_in">erase</span>(pos,n)<span class="comment">//把字符串s从pos开始的n个字符删除</span></span><br><span class="line"><span class="number">5.</span><span class="function">mt19937_64 <span class="title">rng</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="comment">//以实时时间作为种子产生一个64位数的随机数，调用的时候写rng(),可能为正也可能为负</span></span><br><span class="line"><span class="number">6.</span>__builtin_popcount( )<span class="comment">//返回括号内数字二进制表达中1的个数</span></span><br><span class="line"><span class="number">7.</span><span class="comment">//二维map（以int为例）</span></span><br><span class="line">map&lt;<span class="type">int</span>,map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;mp;</span><br><span class="line"><span class="number">8.f</span><span class="keyword">or</span> (<span class="keyword">auto</span> t : &#123;<span class="string">&quot;DFS&quot;</span>, <span class="string">&quot;dfs&quot;</span>&#125;<span class="comment">//t[0]有两个，是D和d。都等效为t[0]</span></span><br><span class="line"><span class="number">9.</span><span class="built_in">substr</span>(起始位置，长度)<span class="comment">//用来截取string类型的字符串 </span></span><br><span class="line"><span class="number">10</span> s.<span class="built_in">replace</span>(p0,n0,n,ch)<span class="comment">//删除p0开始的n0个字符，然后在p0处插入n个字符ch</span></span><br><span class="line"><span class="number">11.</span><span class="comment">//在平面内，从(0,0)到点(x,y)的路径数f[x][y]=f[x-1][y]+f[x][y-1]</span></span><br><span class="line"><span class="number">12.</span><span class="comment">//ceil函数向上取整（对浮点）</span></span><br><span class="line"><span class="number">13.</span><span class="comment">// 0x7fffffff表示int类型的最大值(7个f)</span></span><br><span class="line"><span class="number">14.</span><span class="comment">//在数字前面补零 printf(“%050d”,n)-----格式化输出50位的n，不够的在前面补零。</span></span><br><span class="line"><span class="number">15.</span><span class="comment">//double型不能用位运算</span></span><br><span class="line"><span class="number">16.</span><span class="comment">// 用cout输出的时候Setprecision(p)表示保留有效数字p位</span></span><br><span class="line"><span class="comment">//再加fixed前面修饰可以改为保留小数点后p位</span></span><br><span class="line"><span class="number">17.</span><span class="comment">//setw用来设置字段宽度</span></span><br><span class="line"><span class="number">18.</span><span class="comment">//加0边ascll，减0变int，减‘a’求第几个位置，%26防止爆位</span></span><br><span class="line"><span class="number">19.</span><span class="comment">//类似对1e9+7取模要从一开始计算的时候就取，不能只对答案取模</span></span><br><span class="line"><span class="number">20.</span><span class="comment">//gcd(a,b)和lcm(a,b)在a,b最小的情况下就是a=gcd（a,b）与b=lcm（a,b）;</span></span><br><span class="line"><span class="number">21.</span><span class="comment">//用k加 （1e9+7）再模1e9+7防止因k小于0造成的错误</span></span><br><span class="line"><span class="number">22.</span><span class="comment">//异或实际上就是二进制的不进位加法，异或同一个数两次相当于没有异或这个数</span></span><br><span class="line"><span class="number">23.</span><span class="comment">//iota配合sort实现单数组的多数组对应下标绑定排序</span></span><br><span class="line"><span class="number">24.</span>.iota（起始位，末位，初始值）<span class="comment">//用来批量递增赋值数组，增量为1 </span></span><br><span class="line"><span class="number">25.</span><span class="comment">//用STL包括位运算可能爆int的时候记得写成0LL,1LL</span></span><br><span class="line"><span class="number">26.</span><span class="comment">//二分查找.lower_bound和upper找不到会返回数组最后一个元素下标+1       </span></span><br><span class="line"><span class="number">27.</span><span class="comment">//清空标记形不要用vector,用C-array老实的memset</span></span><br><span class="line"><span class="number">28.</span><span class="comment">//iota配合sort执行结构化排序 举例</span></span><br><span class="line"><span class="comment">//iota(p.begin(),p.end(),0);</span></span><br><span class="line"><span class="comment">//sort(p.begin(),p.end(),[&amp;](int i,int j)&#123;</span></span><br><span class="line"><span class="comment">//  return a[i]&lt;a[j];</span></span><br><span class="line"><span class="comment">//&#125;);</span></span><br><span class="line"><span class="comment">//该代码执行后是p中元素按照a的元素大小进行排序,a[p[0]]就是a中第0小的元素值</span></span><br><span class="line"><span class="comment">//p[0]就是这个第一小的元素在原数组中的坐标</span></span><br><span class="line"><span class="number">29</span> <span class="comment">//转移的时候,记得初始化所有的最左端点的前一个数(-1/0)</span></span><br><span class="line"><span class="comment">//所有的右端点初始化为右端点的后一个数(n/n+1)</span></span><br><span class="line"><span class="number">30</span> <span class="comment">//vector二分插入，保证数组有序</span></span><br><span class="line"><span class="comment">//a.insert(upper_bound(a.begin(),a.end(),x),x);</span></span><br><span class="line"><span class="comment">//insert是在迭代器前一个位置插入元素</span></span><br></pre></td></tr></table></figure><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>10进制转其他进制（n是数字，r是进制）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">char</span>&gt;it;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> s=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">10</span>;i&lt;=<span class="number">15</span>;i++)&#123;</span><br><span class="line">        it[i]=s++;</span><br><span class="line">        cout&lt;&lt;it[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();<span class="type">int</span> r,n;stack&lt;<span class="type">int</span>&gt; s; cin&gt;&gt;n&gt;&gt;r;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        s.<span class="built_in">push</span>(n%r);</span><br><span class="line">        n/=r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">top</span>()&lt;<span class="number">10</span>) cout&lt;&lt;s.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;it[s.<span class="built_in">top</span>()];</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其他进制转十进制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;it;</span><br><span class="line"><span class="type">int</span> r,ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i=<span class="string">&#x27;A&#x27;</span>;i&lt;=<span class="string">&#x27;Z&#x27;</span>;i++) &#123;</span><br><span class="line">        it[i]=s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string n;cin&gt;&gt;r&gt;&gt;n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        ans*=r;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isalpha</span>(n[i])) ans+=it[n[i]];</span><br><span class="line">        <span class="keyword">else</span> ans+=n[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>字符串进制转化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stoi</span>(s) <span class="comment">//s需要是字符串，只能将string类型字符串转化为10进制，且不超过int范围</span></span><br><span class="line"><span class="keyword">auto</span> s=<span class="built_in">to_string</span>(x)<span class="comment">//将x转化为字符串形式    </span></span><br></pre></td></tr></table></figure><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>左端点减1，右端点加1</p><h2 id="三分模板"><a href="#三分模板" class="headerlink" title="三分模板"></a>三分模板</h2><h3 id="整数三分"><a href="#整数三分" class="headerlink" title="整数三分"></a>整数三分</h3><p>每次都将区间变为[l,mid1],(mid1,mid2],(mid2,r]三个区间<br>根据条件判断将l,r指针移动至哪个区间，复杂度为log以3为底(区间大小)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">2</span>,r=<span class="number">999</span>;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid1 = l + (r - l) / <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> mid2 = r - (r - l) / <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> s=<span class="built_in">query</span>(mid1,mid2);</span><br><span class="line">        <span class="keyword">if</span> (s == mid1 * mid2)&#123;</span><br><span class="line">            l = mid2 + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s == mid1 * mid2 + mid1)&#123;</span><br><span class="line">            l = mid1 + <span class="number">1</span>;</span><br><span class="line">            r = mid2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实数三分"><a href="#实数三分" class="headerlink" title="实数三分"></a>实数三分</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;<span class="comment">//根据条件判断</span></span><br><span class="line"><span class="keyword">while</span>(r - l &lt; eps) &#123;</span><br><span class="line">    <span class="type">double</span> lmid = l + (r - l) / <span class="number">3</span>;</span><br><span class="line">    <span class="type">double</span> rmid = r - (r - l) / <span class="number">3</span>;</span><br><span class="line">    lans = <span class="built_in">cal</span>(lmid),rans = <span class="built_in">cal</span>(rmid);</span><br><span class="line">    <span class="comment">// 求凹函数的极小值</span></span><br><span class="line">    <span class="keyword">if</span>(lans &lt;= rans) r = rmid;</span><br><span class="line">    <span class="keyword">else</span> l = lmid;</span><br><span class="line">    <span class="comment">// 求凸函数的极大值</span></span><br><span class="line">    <span class="keyword">if</span>(lans &gt;= rans) l = lmid;</span><br><span class="line">    <span class="keyword">else</span> r = rmid;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; l &lt;&lt; endl;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/">XCPC模板</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%9D%82%E9%A1%B9/">XCPC杂项</category>
      
      
      <category domain="http://iokanux.com/tags/STL/">STL</category>
      
      <category domain="http://iokanux.com/tags/Pre/">Pre</category>
      
      <category domain="http://iokanux.com/tags/Dif/">Dif</category>
      
      <category domain="http://iokanux.com/tags/Suf/">Suf</category>
      
      <category domain="http://iokanux.com/tags/Stoi/">Stoi</category>
      
      <category domain="http://iokanux.com/tags/trisection/">trisection</category>
      
      <category domain="http://iokanux.com/tags/Trick/">Trick</category>
      
      <category domain="http://iokanux.com/tags/Cross-verification/">Cross-verification</category>
      
      <category domain="http://iokanux.com/tags/high-precision/">high precision</category>
      
      
      <comments>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC/XCPC%E5%9F%BA%E7%A1%80/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>XCPC图论</title>
      <link>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC/XCPC%E5%9B%BE%E8%AE%BA/</link>
      <guid>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC/XCPC%E5%9B%BE%E8%AE%BA/</guid>
      <pubDate>Wed, 11 Sep 2024 05:40:25 GMT</pubDate>
      
      <description>&lt;p&gt;介绍XCPC赛事中图论相关的知识&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>介绍XCPC赛事中图论相关的知识</p><span id="more"></span><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="单源汇最短路-SSSP"><a href="#单源汇最短路-SSSP" class="headerlink" title="单源汇最短路(SSSP)"></a>单源汇最短路(SSSP)</h2><p>Single-Source Shortest Path</p><h3 id="正权边-Dijikstra"><a href="#正权边-Dijikstra" class="headerlink" title="正权边(Dijikstra)"></a>正权边(Dijikstra)</h3><p>堆优化版本能在mlogn时间复杂度内求起点到其余所有点的最短路径(m为边,n为点)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> dijkstra=[&amp;](<span class="type">int</span> fi,<span class="type">int</span> se)&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dist</span>(n<span class="number">+10</span>,inf);</span><br><span class="line">        priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;&gt;&gt; heap;</span><br><span class="line">        heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, fi&#125;);</span><br><span class="line">        <span class="keyword">while</span> (heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> [d,u] =heap.<span class="built_in">top</span>();</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (dist[u]!=inf) <span class="keyword">continue</span>;</span><br><span class="line">            dist[u]=d;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [i,w]:g[u])&#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[i] &gt; dist[u] + w)&#123;</span><br><span class="line">                    dist[i] = dist[u] + w;</span><br><span class="line">                    heap.<span class="built_in">push</span>(&#123;dist[i], i&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist[se];</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h3 id="负权边-Bellman-ford"><a href="#负权边-Bellman-ford" class="headerlink" title="负权边(Bellman ford)"></a>负权边(Bellman ford)</h3><p>使用结构体存边（该算法无需存图），以O(NM) 的复杂度计算，N−1 轮后仍无法得到答案（一般与 INF&#x2F;2进行比较）的点，到达其的路径上存在负环。</p><p>下方代码例题：求解从 1 到 n 号节点的、最多经过 k 条边的最短距离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">550</span>, M = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123; <span class="type">int</span> x, y, w; &#125; ver[M];</span><br><span class="line"><span class="type">int</span> d[N], backup[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d); d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup, d, <span class="keyword">sizeof</span> d);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;<span class="comment">//如果为双向边，m改为边的总条数</span></span><br><span class="line">            <span class="type">int</span> x = ver[j].x, y = ver[j].y, w = ver[j].w;</span><br><span class="line">            d[y] = <span class="built_in">min</span>(d[y], backup[x] + w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        ver[i] = &#123;x, y, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bf</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] &gt; INF / <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;N&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; d[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="负权边-SPFA"><a href="#负权边-SPFA" class="headerlink" title="负权边(SPFA)"></a>负权边(SPFA)</h3><p>按理说复杂度为O(KM),K为常数,但有时会退化至O(NM)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">dist</span>(n<span class="number">+1</span>,<span class="number">1e9</span>),<span class="built_in">st</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">auto</span> spfa=[&amp;]()&#123;</span><br><span class="line">        dist[s]=<span class="number">0</span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt;q;q.<span class="built_in">push</span>(s);</span><br><span class="line">        st[s]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();st[t]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y]:g[t])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[x]&gt;dist[t]+y)&#123;</span><br><span class="line">                    dist[x]=dist[t]+y;</span><br><span class="line">                    <span class="keyword">if</span>(!st[x])&#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(x);</span><br><span class="line">                        st[x]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">spfa</span>();</span><br></pre></td></tr></table></figure><h2 id="多源汇最短路-APSP"><a href="#多源汇最短路-APSP" class="headerlink" title="多源汇最短路(APSP)"></a>多源汇最短路(APSP)</h2><p>All-Pairs Shortest Paths</p><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p>使用邻接矩阵存图，可以处理负权边，以 O($N^3$) 的复杂度计算。<strong>注意，这里建立的是单向边，计算双向边需要额外加边</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="type">int</span> n, m, d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )<span class="comment">//注意，枚举中间点的要放在最外层</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line">    <span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        d[x][y] = <span class="built_in">min</span>(d[x][y], w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[i][j] &gt; INF / <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;N&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; d[i][j] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><h3 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> dfs = [&amp;](<span class="keyword">auto</span> self, <span class="type">int</span> x, <span class="type">int</span> type) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">    vis[x] = type;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> y : ver[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[y] == type) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">self</span>(self, y, <span class="number">3</span> - type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[i]) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(dfs, i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="连通性相关"><a href="#连通性相关" class="headerlink" title="连通性相关"></a>连通性相关</h2><h3 id="割点与桥"><a href="#割点与桥" class="headerlink" title="割点与桥"></a>割点与桥</h3><h4 id="割点-cut-vertex-articulation-point）"><a href="#割点-cut-vertex-articulation-point）" class="headerlink" title="割点(cut vertex &#x2F; articulation point）"></a>割点(cut vertex &#x2F; articulation point）</h4><p>给出定义：删除该点后导致图不再连通的点称为割点</p><p>求割点的方法称为tarjan，在连通性相关的问题中广泛运用了该方法</p><p>tarjan的主要思想就是dfn与low数组</p><p>dfn：时间戳数组，dfn[i]称为节点i的dfs序</p><p>dfs序指的是在dfs过程中，该节点是第几个被访问到的节点。dfn数组的值随dfs过程单调上升。</p><p>low[i] 代表节点 i 在不直接返回父亲节点的情况下，通过“绕路”，能够访问到的节点里，最小的dfn值</p><p>由于割点与dfn数组的性质，不返回父亲节点的情况下，割点u的子结点中一定存在一点v使得dfn[u]&lt;&#x3D;low[v]</p><p>特别的，根节点的判断方法为子节点大于1</p><p>由于代码较为简单，割点代码不提供封装写法，有兴趣可以自行封装</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> dfs=[&amp;](<span class="keyword">auto</span> self,<span class="type">int</span> u,<span class="type">int</span> p)-&gt;<span class="type">void</span>&#123;</span><br><span class="line">        dfn[u]=low[u]=cur++;</span><br><span class="line">        <span class="type">int</span> son=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:g[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfn[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">                son++;</span><br><span class="line">                <span class="built_in">self</span>(self,i,u);</span><br><span class="line">                low[u]=<span class="built_in">min</span>(low[u],low[i]);</span><br><span class="line">                <span class="keyword">if</span>(p!=<span class="number">-1</span>&amp;&amp;low[i]&gt;=dfn[u])&#123;</span><br><span class="line">                    st[u]=<span class="number">1</span>;<span class="comment">//此时u为割点</span></span><br><span class="line">                    <span class="comment">//且每标记一次，共用该点的连通块数量就加1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i!=p)&#123;</span><br><span class="line">                low[u]=<span class="built_in">min</span>(low[u],dfn[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">-1</span>&amp;&amp;son&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            st[u]=<span class="number">1</span>;<span class="comment">//此时u为割点</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//根节点的共用连通块数量是son-1，求连通块时不必特判son&gt;1</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h4 id="割边-桥-cut-edge-bridge"><a href="#割边-桥-cut-edge-bridge" class="headerlink" title="割边&#x2F;桥(cut edge&#x2F;bridge)"></a>割边&#x2F;桥(cut edge&#x2F;bridge)</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> dfs=[&amp;](<span class="keyword">auto</span> self,<span class="type">int</span> u, <span class="type">int</span> p)-&gt;<span class="type">void</span>&#123;</span><br><span class="line">        low[u] = dfn[u] = ++cur;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i:g[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">                <span class="built_in">self</span>(self,i, u);</span><br><span class="line">                low[u] = <span class="built_in">min</span>(low[u], low[i]);</span><br><span class="line">                <span class="keyword">if</span> (low[i] &gt; dfn[u]) &#123;</span><br><span class="line">                    <span class="type">int</span> l=<span class="built_in">min</span>(u,i),r=<span class="built_in">max</span>(u,i);</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;l,r&#125;);<span class="comment">//v,u为割边</span></span><br><span class="line">                    ++cnt;<span class="comment">//cnt为割边数量</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dfn[i]&lt;dfn[u]&amp;&amp;i != p) &#123;</span><br><span class="line">                low[u] = <span class="built_in">min</span>(low[u], dfn[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dfs</span>(dfs,<span class="number">1</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="强连通分量-SCC"><a href="#强连通分量-SCC" class="headerlink" title="强连通分量(SCC)"></a>强连通分量(SCC)</h3><p>强连通分量(Strongly Connected Components)，讨论有向图</p><p>有向图 G 强连通是指，G 中任意两个结点连通。</p><p>强连通分量缩点</p><p>性质：缩点后的图拥有拓扑序 colorcnt,colorcnt−1,…,1colorcnt,colorcnt−1,…,1 ，可以不需再另跑一遍 topsort ；缩点后的图是一张有向无环图（ DAG、拓扑图）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SCC</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adj;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dfn, low, bel;</span><br><span class="line">    <span class="type">int</span> cur, cnt;</span><br><span class="line">    <span class="built_in">SCC</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">SCC</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        adj.<span class="built_in">assign</span>(n, &#123;&#125;);</span><br><span class="line">        dfn.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">        low.<span class="built_in">resize</span>(n);</span><br><span class="line">        bel.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">        stk.<span class="built_in">clear</span>();</span><br><span class="line">        cur = cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        dfn[x] = low[x] = cur++;</span><br><span class="line">        stk.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y : adj[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfn[y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(y);</span><br><span class="line">                low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bel[y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                y = stk.<span class="built_in">back</span>();</span><br><span class="line">                bel[y] = cnt;</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125; <span class="keyword">while</span> (y != x);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfn[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bel;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Employ"><a href="#Employ" class="headerlink" title="Employ"></a>Employ</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SCC <span class="title">scc</span><span class="params">(n<span class="number">+1</span>)</span></span>;<span class="comment">//所有点初始化</span></span><br><span class="line">scc.<span class="built_in">addEdge</span>(u,v);<span class="comment">//u,v连有向边，u-&gt;v</span></span><br><span class="line"><span class="keyword">auto</span> bel=scc.<span class="built_in">work</span>()<span class="comment">//执行强连通分量缩点，返回的是vector</span></span><br><span class="line"><span class="comment">//bel表示每个点所在的强连通分量标号,n个点最多n个强连通分量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/***缩点完重新建图***/</span></span><br><span class="line"><span class="comment">//“超级点的点权根据题意确定,此时点重新命名为bel[i]”</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j:g[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(bel[i]!=bel[j])&#123;</span><br><span class="line">                adj[bel[i]].<span class="built_in">push_back</span>(bel[j]);</span><br><span class="line">                in[bel[j]]++;<span class="comment">//存储入度</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;scc.cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            ans+=sum[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></figure><h3 id="双连通分量-Biconnected-component"><a href="#双连通分量-Biconnected-component" class="headerlink" title="双连通分量 (Biconnected component)"></a>双连通分量 (Biconnected component)</h3><p>由于是双连通图，所以这部分讨论的均为无向图</p><h4 id="边双连通分量-EBC"><a href="#边双连通分量-EBC" class="headerlink" title="边双连通分量 (EBC)"></a>边双连通分量 (EBC)</h4><p>边双是Edge Biconnected Component，所以其实是EBCC，但是为了和割边缩点(EBCC)区别开，这里我们命名为EBC</p><p>给出定义：不存在割边&#x2F;桥的极大双连通子图称为边双连通分量</p><p>所以求边双的方法也很显然，将一张图中的所有割边&#x2F;桥断掉后，剩下的连通块均为一个边双，边双与边双之间以割边&#x2F;桥连接成一棵树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">EBC</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;PII&gt;&gt;adj;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;dfn,low,stk;</span><br><span class="line">    <span class="type">int</span> cur,n;</span><br><span class="line">    <span class="built_in">EBC</span>()&#123;&#125;;</span><br><span class="line">    <span class="built_in">EBC</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n=n;</span><br><span class="line">        adj.<span class="built_in">resize</span>(n,&#123;&#125;);</span><br><span class="line">        dfn.<span class="built_in">resize</span>(n,<span class="number">-1</span>);</span><br><span class="line">        low.<span class="built_in">resize</span>(n);</span><br><span class="line">        stk.<span class="built_in">clear</span>();</span><br><span class="line">        cur=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(&#123;v,i&lt;&lt;<span class="number">1</span>&#125;);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(&#123;u,i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">        stk.<span class="built_in">push_back</span>(u);</span><br><span class="line">        dfn[u]=low[u]=cur++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:adj[u])&#123;</span><br><span class="line">            <span class="keyword">if</span>(i.second==(p^<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfn[i.first]==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i.first,i.second);</span><br><span class="line">                low[u]=<span class="built_in">min</span>(low[u],low[i.first]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low[u]=<span class="built_in">min</span>(low[u],dfn[i.first]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                y=stk.<span class="built_in">back</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(y);</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;<span class="keyword">while</span>(y!=u);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">work</span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfn[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Employ-1"><a href="#Employ-1" class="headerlink" title="Employ"></a>Employ</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EBC <span class="title">ebc</span><span class="params">(n<span class="number">+1</span>)</span></span>;<span class="comment">//建EBC</span></span><br><span class="line">ebc.<span class="built_in">edge</span>(u,v,i)<span class="comment">//i是for读入数据的i</span></span><br><span class="line"><span class="keyword">auto</span> ans=ebc.<span class="built_in">work</span>()<span class="comment">//ans数组存储每个双连通分量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:ans)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> j:i)&#123;</span><br><span class="line">        <span class="comment">//每个边双的点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="点双连通分量-VBC"><a href="#点双连通分量-VBC" class="headerlink" title="点双连通分量(VBC)"></a>点双连通分量(VBC)</h4><p>点双Vertex Biconnected Component</p><p>不存在割点的极大双连通子图</p><p>割点缩点后的图称为点双连通图 (V-DCC)，该模板可以在 O(N+M)O(N+M) 复杂度内求解图中全部割点、划分点双（颜色相同的点位于同一个点双连通分量中）。</p><p>性质补充：每一个割点至少属于两个点双。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">V_DCC</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ver, col;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dfn, low, S;</span><br><span class="line">    <span class="type">int</span> now, cnt;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; point; <span class="comment">// 记录是否为割点</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">V_DCC</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n) &#123;</span><br><span class="line">        ver.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        dfn.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        low.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        col.<span class="built_in">resize</span>(<span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">        point.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        S.<span class="built_in">clear</span>();</span><br><span class="line">        cnt = now = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span>; <span class="comment">// 手动去除重边</span></span><br><span class="line">        ver[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        ver[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">        low[x] = dfn[x] = now++;</span><br><span class="line">        S.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (x == root &amp;&amp; !ver[x].<span class="built_in">size</span>()) &#123; <span class="comment">// 特判孤立点</span></span><br><span class="line">            ++cnt;</span><br><span class="line">            col[cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y : ver[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(y, root);</span><br><span class="line">                low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">                <span class="keyword">if</span> (dfn[x] &lt;= low[y]) &#123;</span><br><span class="line">                    flag++;</span><br><span class="line">                    <span class="keyword">if</span> (x != root || flag &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        point[x] = <span class="literal">true</span>; <span class="comment">// 标记为割点</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        pre = S.<span class="built_in">back</span>();</span><br><span class="line">                        col[cnt].<span class="built_in">push_back</span>(pre);</span><br><span class="line">                        S.<span class="built_in">pop_back</span>();</span><br><span class="line">                    &#125; <span class="keyword">while</span> (pre != y);</span><br><span class="line">                    col[cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pair&lt;<span class="type">int</span>, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">rebuild</span>() &#123; <span class="comment">// [新图的顶点数量, 新图]</span></span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(cnt + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!col[i].<span class="built_in">size</span>()) &#123; <span class="comment">// 注意，孤立点也是 V-DCC</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j : col[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (point[j]) &#123; <span class="comment">// 如果 j 是割点</span></span><br><span class="line">                    adj[i].<span class="built_in">push_back</span>(point[j]);</span><br><span class="line">                    adj[point[j]].<span class="built_in">push_back</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;cnt, adj&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; <span class="comment">// 避免图不连通</span></span><br><span class="line">            <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="割边与割边缩点-EBCC"><a href="#割边与割边缩点-EBCC" class="headerlink" title="割边与割边缩点(EBCC)"></a>割边与割边缩点(EBCC)</h3><p>性质补充：对于一个边双，删去任意边后依旧联通；对于边双中的任意两点，一定存在两条不相交的路径连接这两个点（路径上可以有公共点，但是没有公共边）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">set&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; E;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EBCC</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; adj;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dfn, low, bel;</span><br><span class="line">    <span class="type">int</span> cur, cnt;</span><br><span class="line">    <span class="built_in">EBCC</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">EBCC</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        adj.<span class="built_in">assign</span>(n, &#123;&#125;);</span><br><span class="line">        dfn.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">        low.<span class="built_in">resize</span>(n);</span><br><span class="line">        bel.<span class="built_in">assign</span>(n, <span class="number">-1</span>);</span><br><span class="line">        stk.<span class="built_in">clear</span>();</span><br><span class="line">        cur = cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        dfn[x] = low[x] = cur++;</span><br><span class="line">        stk.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> y : adj[x]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (y == p) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dfn[y] == <span class="number">-1</span>) &#123;</span><br><span class="line">                E.<span class="built_in">emplace</span>(x, y);</span><br><span class="line">                <span class="built_in">dfs</span>(y, x);</span><br><span class="line">                low[x] = std::<span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bel[y] == <span class="number">-1</span> &amp;&amp; dfn[y] &lt; dfn[x]) &#123;</span><br><span class="line">                E.<span class="built_in">emplace</span>(x, y);</span><br><span class="line">                low[x] = std::<span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                y = stk.<span class="built_in">back</span>();</span><br><span class="line">                bel[y] = cnt;</span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125; <span class="keyword">while</span> (y != x);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行主体,返回bel,bel[u]指u点缩点后是哪个点</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> bel;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="comment">//缩点后的点数</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">        <span class="comment">//缩点后的边</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; siz;</span><br><span class="line">        <span class="comment">//缩点的点包含原先的点数</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; cnte;</span><br><span class="line">        <span class="comment">//缩点的点包含的原先的边+该点到其儿子的边数的个数</span></span><br><span class="line">        <span class="comment">//父亲和儿子由dfn序决定</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">Graph <span class="title">compress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Graph g;</span><br><span class="line">        g.n = cnt;</span><br><span class="line">        g.siz.<span class="built_in">resize</span>(cnt);</span><br><span class="line">        g.cnte.<span class="built_in">resize</span>(cnt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            g.siz[bel[i]]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j : adj[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bel[i] &lt; bel[j]) &#123;</span><br><span class="line">                    g.edges.<span class="built_in">emplace_back</span>(bel[i], bel[j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                    g.cnte[bel[i]]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Employ-2"><a href="#Employ-2" class="headerlink" title="Employ"></a>Employ</h4><p>仅连通图可以用，将所有的桥边割掉</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EBCC <span class="title">g</span><span class="params">(n<span class="number">+1</span>)</span></span>; <span class="comment">//建EBCC</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    <span class="type">int</span> u,v;cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">    g.<span class="built_in">addEdge</span>(u,v);  <span class="comment">//加边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> res=g.<span class="built_in">work</span>();  <span class="comment">//执行EBCC割边,返回各点缩点后的对应的点</span></span><br><span class="line"><span class="comment">//判断整个图是边双的，count(res.begin(),res.end(),0)&lt;n不是边双</span></span><br><span class="line"><span class="keyword">auto</span> [ng,edges,siz,cnte]=g.<span class="built_in">compress</span>(); <span class="comment">//获取割边缩点后的图的信息</span></span><br><span class="line"><span class="comment">//建立割边缩点后的图(注意如果原图给的有重边，edges也会存有重边)</span></span><br><span class="line"><span class="comment">//重边情况将Graph里的edges改为set存储即可</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">adj</span>(ng);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[u,v]:edges)&#123;</span><br><span class="line">    adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出一种无向边改有向边的方式,使得更改后满足:整个图是强连通的</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>[x,y]:E) &#123;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树链剖分-HLD"><a href="#树链剖分-HLD" class="headerlink" title="树链剖分(HLD)"></a>树链剖分(HLD)</h2><p>重链剖分</p><p>Heavy-Light Decomposition</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HLD</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; siz, top, dep, parent, in, out, seq;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adj;</span><br><span class="line">    <span class="type">int</span> cur;</span><br><span class="line">    <span class="built_in">HLD</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">HLD</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        siz.<span class="built_in">resize</span>(n);</span><br><span class="line">        top.<span class="built_in">resize</span>(n);</span><br><span class="line">        dep.<span class="built_in">resize</span>(n);</span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        in.<span class="built_in">resize</span>(n);</span><br><span class="line">        out.<span class="built_in">resize</span>(n);</span><br><span class="line">        seq.<span class="built_in">resize</span>(n);</span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        adj.<span class="built_in">assign</span>(n, &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> root = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        top[root] = root;</span><br><span class="line">        dep[root] = <span class="number">0</span>;</span><br><span class="line">        parent[root] = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(root);</span><br><span class="line">        <span class="built_in">dfs2</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           标记每个点的深度dep[]</span></span><br><span class="line"><span class="comment">           标记每个点的父亲parent[]</span></span><br><span class="line"><span class="comment">           标记每个非叶子节点的子树大小(含它自己)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (parent[u] != <span class="number">-1</span>) &#123;</span><br><span class="line">            adj[u].<span class="built_in">erase</span>(<span class="built_in">find</span>(adj[u].<span class="built_in">begin</span>(), adj[u].<span class="built_in">end</span>(), parent[u]));</span><br><span class="line">        &#125;</span><br><span class="line">        siz[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : adj[u]) &#123;</span><br><span class="line">            parent[v] = u;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(v);</span><br><span class="line">            siz[u] += siz[v];</span><br><span class="line">            <span class="keyword">if</span> (siz[v] &gt; siz[adj[u][<span class="number">0</span>]]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(v, adj[u][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        in[u] = cur++;</span><br><span class="line">        seq[in[u]] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u]) &#123;</span><br><span class="line">            top[v] = v == adj[u][<span class="number">0</span>] ? top[u] : v;</span><br><span class="line">            <span class="built_in">dfs2</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        out[u] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;</span><br><span class="line">                u = parent[top[u]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = parent[top[v]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dist</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回两点的距离</span></span><br><span class="line">        <span class="keyword">return</span> dep[u] + dep[v] - <span class="number">2</span> * dep[<span class="built_in">lca</span>(u, v)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向上跳k步，返回跳跃后的节点</span></span><br><span class="line">        <span class="keyword">if</span> (dep[u] &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> d = dep[u] - k;</span><br><span class="line">        <span class="keyword">while</span> (dep[top[u]] &gt; d) &#123;</span><br><span class="line">            u = parent[top[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> seq[in[u] - dep[u] + d];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAncester</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断u是否是v的祖先</span></span><br><span class="line">        <span class="keyword">return</span> in[u] &lt;= in[v] &amp;&amp; in[v] &lt; out[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rootedParent</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在以u为根的子树中，找到v的直接父节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">swap</span>(u, v);</span><br><span class="line">        <span class="keyword">if</span> (u == v) &#123;</span><br><span class="line">            <span class="keyword">return</span> u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isAncester</span>(u, v)) &#123;</span><br><span class="line">            <span class="keyword">return</span> parent[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">upper_bound</span>(adj[u].<span class="built_in">begin</span>(), adj[u].<span class="built_in">end</span>(), v, [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> in[x] &lt; in[y];</span><br><span class="line">        &#125;) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rootedSize</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 在以u为根的子树中，计算以v为根的子树的大小</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (u == v) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isAncester</span>(v, u)) &#123;</span><br><span class="line">            <span class="keyword">return</span> siz[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - siz[<span class="built_in">rootedParent</span>(u, v)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rootedLca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lca</span>(a, b) ^ <span class="built_in">lca</span>(b, c) ^ <span class="built_in">lca</span>(c, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="树相关"><a href="#树相关" class="headerlink" title="树相关"></a>树相关</h2><h3 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ver;</span><br><span class="line">    <span class="built_in">Tree</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        ver.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        ver[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        ver[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getlen</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123; <span class="comment">// 获取x所在树的直径</span></span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dep; <span class="comment">// map用于优化输入为森林时的深度计算，亦可用vector</span></span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> x, <span class="type">int</span> fa) -&gt; <span class="type">void</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> y : ver[x]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">                dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(y, x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dep[x] &gt; dep[root]) &#123;</span><br><span class="line">                root = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> st = root; <span class="comment">// 记录直径端点</span></span><br><span class="line">        </span><br><span class="line">        dep.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> ed = root; <span class="comment">// 记录直径另一端点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dep[root];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="树论大封装"><a href="#树论大封装" class="headerlink" title="树论大封装"></a>树论大封装</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; e;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dep, parent, maxdep, d1, d2, s1, s2, up;</span><br><span class="line">    <span class="built_in">Tree</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        e.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        dep.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        parent.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        maxdep.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        d<span class="number">1.</span><span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        d<span class="number">2.</span><span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        s<span class="number">1.</span><span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        s<span class="number">2.</span><span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">        up.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(&#123;w, v&#125;);</span><br><span class="line">        e[v].<span class="built_in">push_back</span>(&#123;w, u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">        maxdep[u] = dep[u];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [w, v] : e[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            parent[v] = u;</span><br><span class="line">            <span class="built_in">dfs</span>(v, u);</span><br><span class="line">            maxdep[u] = <span class="built_in">max</span>(maxdep[u], maxdep[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [w, v] : e[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">            <span class="type">int</span> x = d1[v] + w;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; d1[u]) &#123;</span><br><span class="line">                d2[u] = d1[u], s2[u] = s1[u];</span><br><span class="line">                d1[u] = x, s1[u] = v;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; d2[u]) &#123;</span><br><span class="line">                d2[u] = x, s2[u] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [w, v] : e[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (s1[u] == v) &#123;</span><br><span class="line">                up[v] = <span class="built_in">max</span>(up[u], d2[u]) + w;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                up[v] = <span class="built_in">max</span>(up[u], d1[u]) + w;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs2</span>(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> radius, center, diam;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getCenter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        center = <span class="number">1</span>; <span class="comment">//中心</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">max</span>(d1[i], up[i]) &lt; <span class="built_in">max</span>(d1[center], up[center])) &#123;</span><br><span class="line">                center = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        radius = <span class="built_in">max</span>(d1[center], up[center]); <span class="comment">//距离最远点的距离的最小值</span></span><br><span class="line">        diam = d1[center] + up[center] + <span class="number">1</span>; <span class="comment">//直径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rem; <span class="comment">//删除重心后剩余连通块体积的最小值</span></span><br><span class="line">    <span class="type">int</span> cog; <span class="comment">//重心</span></span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getCog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vis.<span class="built_in">resize</span>(n);</span><br><span class="line">        rem = INT_MAX;</span><br><span class="line">        cog = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfsCog</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfsCog</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [w, v] : e[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">dfsCog</span>(v);</span><br><span class="line">            res = <span class="built_in">max</span>(res, t);</span><br><span class="line">            s += t;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, n - s);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; rem) &#123;</span><br><span class="line">            rem = res;</span><br><span class="line">            cog = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="最小生成树-MST"><a href="#最小生成树-MST" class="headerlink" title="最小生成树(MST)"></a>最小生成树(MST)</h2><p>Minimum Spanning Tree</p><h3 id="Prim-稀疏图"><a href="#Prim-稀疏图" class="headerlink" title="Prim(稀疏图)"></a>Prim(稀疏图)</h3><p>使用邻接矩阵存图，以 O($N^2+M$)的复杂度计算，思想与djikstra 基本一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">550</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n, m, g[N][N];</span><br><span class="line"><span class="type">int</span> d[N], v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ms</span>(d, <span class="number">0x3f</span>); <span class="comment">//这里的d表示到“最小生成树集合”的距离</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123; <span class="comment">//遍历 n 轮</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (v[j] == <span class="number">0</span> &amp;&amp; (t == <span class="number">-1</span> || d[j] &lt; d[t])) <span class="comment">//如果这个点不在集合内且当前距离集合最近</span></span><br><span class="line">                t = j;</span><br><span class="line">        v[t] = <span class="number">1</span>; <span class="comment">//将t加入“最小生成树集合”</span></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; d[t] == INF) <span class="keyword">return</span> INF; <span class="comment">//如果发现不连通，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (i) ans += d[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) d[j] = <span class="built_in">min</span>(d[j], g[t][j]); <span class="comment">//用t更新其他点到集合的距离</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ms</span>(g, <span class="number">0x3f</span>); cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m -- ) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        g[x][y] = g[y][x] = <span class="built_in">min</span>(g[x][y], w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">if</span> (t == INF) cout &lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Kruskal-稠密图"><a href="#Kruskal-稠密图" class="headerlink" title="Kruskal(稠密图)"></a>Kruskal(稠密图)</h3><p>平均时间复杂度O(MlogM)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; fa;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n) : <span class="built_in">fa</span>(n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">iota</span>(fa.<span class="built_in">begin</span>(), fa.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != fa[x]) &#123;</span><br><span class="line">            x = fa[x] = fa[fa[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="comment">// 设x是y的祖先</span></span><br><span class="line">        x = <span class="built_in">get</span>(x), y = <span class="built_in">get</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        fa[y] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">get</span>(x) == <span class="built_in">get</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> TII = tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    priority_queue&lt;TII, vector&lt;TII&gt;, greater&lt;TII&gt;&gt; ver;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Tree</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        ver.<span class="built_in">emplace</span>(w, x, y); <span class="comment">// 注意顺序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">DSU <span class="title">dsu</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ver.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [w, x, y] = ver.<span class="built_in">top</span>();</span><br><span class="line">            ver.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (dsu.<span class="built_in">same</span>(x, y)) <span class="keyword">continue</span>;</span><br><span class="line">            dsu.<span class="built_in">merge</span>(x, y);</span><br><span class="line">            ans += w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(cnt &lt; n - <span class="number">1</span>); <span class="comment">// 输入有误，建树失败</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Kruskal-重构树"><a href="#Kruskal-重构树" class="headerlink" title="Kruskal 重构树"></a>Kruskal 重构树</h2>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/">XCPC模板</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%9B%BE%E8%AE%BA/">XCPC图论</category>
      
      
      <category domain="http://iokanux.com/tags/SSSP/">SSSP</category>
      
      <category domain="http://iokanux.com/tags/APSP/">APSP</category>
      
      <category domain="http://iokanux.com/tags/Bipartite-Graph/">Bipartite Graph</category>
      
      <category domain="http://iokanux.com/tags/Cut-point/">Cut point</category>
      
      <category domain="http://iokanux.com/tags/SCC/">SCC</category>
      
      <category domain="http://iokanux.com/tags/BCC/">BCC</category>
      
      <category domain="http://iokanux.com/tags/EBCC/">EBCC</category>
      
      <category domain="http://iokanux.com/tags/HLD/">HLD</category>
      
      <category domain="http://iokanux.com/tags/Tree/">Tree</category>
      
      <category domain="http://iokanux.com/tags/MST/">MST</category>
      
      <category domain="http://iokanux.com/tags/Kruskal/">Kruskal</category>
      
      <category domain="http://iokanux.com/tags/Dijkstral/">Dijkstral</category>
      
      <category domain="http://iokanux.com/tags/Bellman-ford/">Bellman ford</category>
      
      <category domain="http://iokanux.com/tags/SPFA/">SPFA</category>
      
      <category domain="http://iokanux.com/tags/Floyd/">Floyd</category>
      
      
      <comments>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC/XCPC%E5%9B%BE%E8%AE%BA/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>XCPC数据结构</title>
      <link>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <guid>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <pubDate>Wed, 11 Sep 2024 05:40:25 GMT</pubDate>
      
      <description>&lt;p&gt;介绍XCPC赛事中的初中高级数据结构，并对部分进行了一定程度上的封装&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>介绍XCPC赛事中的初中高级数据结构，并对部分进行了一定程度上的封装</p><span id="more"></span><h1 id="XCPC-数据结构"><a href="#XCPC-数据结构" class="headerlink" title="XCPC 数据结构"></a>XCPC 数据结构</h1><h2 id="双哈希封装"><a href="#双哈希封装" class="headerlink" title="双哈希封装"></a>双哈希封装</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Shash</span>&#123;  </span><br><span class="line">    <span class="type">const</span> ll base[<span class="number">2</span>]=&#123;<span class="number">29</span>,<span class="number">31</span>&#125;;</span><br><span class="line">    <span class="comment">//base存储基数</span></span><br><span class="line">    <span class="type">const</span> ll hashmod[<span class="number">2</span>]=&#123;(ll)<span class="number">1e9</span><span class="number">+9</span>,<span class="number">998244353</span>&#125;;</span><br><span class="line">    <span class="comment">//hashmod存储模数</span></span><br><span class="line">    array&lt;vector&lt;ll&gt;,2&gt;hsh;</span><br><span class="line">    array&lt;vector&lt;ll&gt;,2&gt;pwMod;</span><br><span class="line">    <span class="comment">//hsh[2] 和 pwMod[2]：这两个二维 vector 分别用于存储哈希值和幂模值。</span></span><br><span class="line">    <span class="comment">//其中，hsh[i][j] 表示字符串前 j 个字符在基数 base[i] 和模数 hashmod[i] 下的哈希值；</span></span><br><span class="line">    <span class="comment">//pwMod[i][j] 表示基数 base[i] 的 j 次幂对 hashmod[i] 取模的结果。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(string S)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n=S.<span class="built_in">size</span>();S=<span class="string">&#x27; &#x27;</span>+S;</span><br><span class="line">        hsh[<span class="number">0</span>].<span class="built_in">resize</span>(n<span class="number">+1</span>),hsh[<span class="number">1</span>].<span class="built_in">resize</span>(n<span class="number">+1</span>);</span><br><span class="line">        pwMod[<span class="number">0</span>].<span class="built_in">resize</span>(n<span class="number">+1</span>),pwMod[<span class="number">1</span>].<span class="built_in">resize</span>(n<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)&#123;</span><br><span class="line">            pwMod[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">                pwMod[i][j]=pwMod[i][j<span class="number">-1</span>]*base[i]%hashmod[i];</span><br><span class="line">                hsh[i][j]=(hsh[i][j<span class="number">-1</span>]*base[i]+S[j])%hashmod[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get函数输出[l,r]这段字符的哈希值,first是第一个模数下哈希值,second是第二个</span></span><br><span class="line">    pair&lt;ll,ll&gt;<span class="built_in">get</span>(<span class="type">int</span> l,<span class="type">int</span> r)&#123;</span><br><span class="line">        pair&lt;ll,ll&gt; ans;</span><br><span class="line">        ans.first=(hsh[<span class="number">0</span>][r]-hsh[<span class="number">0</span>][l<span class="number">-1</span>]*pwMod[<span class="number">0</span>][r-l<span class="number">+1</span>])%hashmod[<span class="number">0</span>];</span><br><span class="line">        ans.second=(hsh[<span class="number">1</span>][r]-hsh[<span class="number">1</span>][l<span class="number">-1</span>]*pwMod[<span class="number">1</span>][r-l<span class="number">+1</span>])%hashmod[<span class="number">1</span>];</span><br><span class="line">        ans.first=(ans.first+hashmod[<span class="number">0</span>])%hashmod[<span class="number">0</span>];</span><br><span class="line">        ans.second=(ans.second+hashmod[<span class="number">1</span>])%hashmod[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(Shash &amp;a,<span class="type">int</span> la,<span class="type">int</span> ra,Shash &amp;b,<span class="type">int</span> lb,<span class="type">int</span> rb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">get</span>(la,ra)==b.<span class="built_in">get</span>(lb,rb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shash a;</span><br><span class="line">a.<span class="built_in">init</span>(s)<span class="comment">//s是待处理字符串</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">same</span>(a,l,r,b,l,r))<span class="comment">//判断字符串a,b在l,r区间内是否相等    </span></span><br></pre></td></tr></table></figure><h3 id="删除某几个字符串得到新的哈希值"><a href="#删除某几个字符串得到新的哈希值" class="headerlink" title="删除某几个字符串得到新的哈希值"></a>删除某几个字符串得到新的哈希值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设删除s[i],s[i+1]两个字符，得到新的字符串的哈希值就是hsh[i-1][0]*pmMod[n-(i+1)][0]+get(i+2,n).first</span></span><br><span class="line"><span class="comment">//(以上为在第一个模底下的新的字符串哈希值)</span></span><br></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; f,siz;</span><br><span class="line">    <span class="built_in">DSU</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        f.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        siz.<span class="built_in">assign</span>(n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x]) &#123;</span><br><span class="line">            x = f[x] = f[f[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        f[y] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> siz[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="声明方式-1"><a href="#声明方式-1" class="headerlink" title="声明方式"></a>声明方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DSU <span class="title">dsu</span><span class="params">(N)</span><span class="comment">//声明一个大小为N，名称为dsu的并查集</span></span></span><br><span class="line"><span class="function">dsu.<span class="title">merge</span><span class="params">(a,b)</span><span class="comment">//合并a,b</span></span></span><br><span class="line"><span class="function">dsu.<span class="title">find</span><span class="params">(x)</span><span class="comment">//找到x的祖宗节点</span></span></span><br><span class="line"><span class="function">dsu.<span class="title">size</span><span class="params">(x)</span><span class="comment">//以x为祖宗节点的个数    </span></span></span><br></pre></td></tr></table></figure><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><h3 id="线段树-SegmentTree-Info"><a href="#线段树-SegmentTree-Info" class="headerlink" title="线段树 ( SegmentTree+Info )"></a>线段树 ( SegmentTree+Info )</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc, rc, ls, rs, len, ans;</span><br><span class="line">&#125;;</span><br><span class="line">Info <span class="keyword">operator</span>+(Info a, Info b) &#123;</span><br><span class="line">    Info c = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    c.ans = <span class="built_in">max</span>(a.ans, b.ans);</span><br><span class="line">    <span class="keyword">if</span> (a.rc == <span class="number">0</span> &amp;&amp; b.lc == <span class="number">0</span>) c.ans = <span class="built_in">max</span>(c.ans, a.rs + b.ls);</span><br><span class="line">    c.lc = a.lc, c.rc = b.rc;</span><br><span class="line">    c.ls = a.ls;</span><br><span class="line">    <span class="keyword">if</span> (a.ls == a.len &amp;&amp; a.rc == b.lc) c.ls += b.ls;</span><br><span class="line">    c.rs = b.rs;</span><br><span class="line">    <span class="keyword">if</span> (b.rs == b.len &amp;&amp; a.rc == b.lc) c.rs += a.rs;</span><br><span class="line">    c.len = a.len + b.len;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segtree</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        Info info;</span><br><span class="line">    &#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        tr[u].info = tr[u &lt;&lt; <span class="number">1</span>].info + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].info;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tr[u].info = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pull</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[u].l == tr[u].r) &#123;</span><br><span class="line">            tr[u].info.lc ^= <span class="number">1</span>;</span><br><span class="line">            tr[u].info.rc ^= <span class="number">1</span>;</span><br><span class="line">            tr[u].info.ans ^= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x);</span><br><span class="line">        <span class="built_in">pull</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Info <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].info;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r) + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    t.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> op;cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">            t.<span class="built_in">modify</span>(<span class="number">1</span>,x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">            cout&lt;&lt;t.<span class="built_in">query</span>(<span class="number">1</span>,l,r).ans&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LazySegmentTree-基础区间修改"><a href="#LazySegmentTree-基础区间修改" class="headerlink" title="LazySegmentTree 基础区间修改"></a>LazySegmentTree 基础区间修改</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Info</span>, <span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LSGT</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(p) (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(p) (p &lt;&lt; 1 | 1)</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;Info&gt; info;</span><br><span class="line">    std::vector&lt;Tag&gt; tag;</span><br><span class="line">    <span class="built_in">LSGT</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">LSGT</span>(<span class="type">int</span> _n, Info _v = <span class="built_in">Info</span>()) &#123;</span><br><span class="line">        <span class="built_in">init</span>(_n, _v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">LSGT</span><span class="params">(std::vector&lt;T&gt; _init)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>(_init);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> _n, Info _v = Info())</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>(std::<span class="built_in">vector</span>(_n, _v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;T&gt; _init)</span> </span>&#123;</span><br><span class="line">        n = _init.<span class="built_in">size</span>();</span><br><span class="line">        info.<span class="built_in">assign</span>(<span class="number">4</span> &lt;&lt; std::__lg(n), <span class="built_in">Info</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(<span class="number">4</span> &lt;&lt; std::__lg(n), <span class="built_in">Tag</span>());</span><br><span class="line">        <span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span> self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">                info[p] = _init[l];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">self</span>(self, <span class="built_in">l</span>(p), l, m);</span><br><span class="line">            <span class="built_in">self</span>(self, <span class="built_in">r</span>(p), m, r);</span><br><span class="line">            <span class="built_in">pull</span>(p);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">build</span>(build, <span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        info[p] = info[<span class="built_in">l</span>(p)] + info[<span class="built_in">r</span>(p)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Tag &amp;v, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        info[p].<span class="built_in">apply</span>(v, len);</span><br><span class="line">        tag[p].<span class="built_in">apply</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">apply</span>(<span class="built_in">l</span>(p), tag[p], len / <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">apply</span>(<span class="built_in">r</span>(p), tag[p], len - len / <span class="number">2</span>);</span><br><span class="line">        tag[p] = <span class="built_in">Tag</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">            info[p] = v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">push</span>(p, r - l);</span><br><span class="line">        <span class="keyword">if</span> (x &lt; m) &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="built_in">l</span>(p), l, m, x, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="built_in">r</span>(p), m, r, x, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Info &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">0</span>, n, p, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y <span class="keyword">or</span> r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Info</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x <span class="keyword">and</span> r &lt;= y) &#123;</span><br><span class="line">            <span class="keyword">return</span> info[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">push</span>(p, r - l);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">l</span>(p), l, m, x, y) + <span class="built_in">query</span>(<span class="built_in">r</span>(p), m, r, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Apply</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Tag &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y <span class="keyword">or</span> r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x <span class="keyword">and</span> r &lt;= y) &#123;</span><br><span class="line">            <span class="built_in">apply</span>(p, v, r - l);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">push</span>(p, r - l);</span><br><span class="line">        <span class="built_in">Apply</span>(<span class="built_in">l</span>(p), l, m, x, y, v);</span><br><span class="line">        <span class="built_in">Apply</span>(<span class="built_in">r</span>(p), m, r, x, y, v);</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Apply</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> Tag &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Apply</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, v);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> l(p)</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> r(p)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">    <span class="comment">// 定义要下放什么标记</span></span><br><span class="line">    <span class="type">int</span> mul,add;</span><br><span class="line">    <span class="comment">//Tag(...): ... &#123;&#125; // 初始化</span></span><br><span class="line">    <span class="built_in">Tag</span>(<span class="type">int</span> _mul=<span class="number">1</span>,<span class="type">int</span> _add=<span class="number">0</span>):<span class="built_in">mul</span>(_mul),<span class="built_in">add</span>(_add)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(Tag t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 怎么用父结点的标记更新儿子的标记</span></span><br><span class="line">        mul=mul*t.mul;</span><br><span class="line">        add=(add*t.mul+t.add);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(Tag t, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是只有add标记,注意sum=sum+t.add;</span></span><br><span class="line">        <span class="comment">// 怎么用父结点的标记更新儿子存储的信息</span></span><br><span class="line">        <span class="comment">// 这里 jls 原本没有区间长度 len 这个形参，但我觉得可能常用就自己加上了</span></span><br><span class="line">        sum = (sum * t.mul + <span class="number">1LL</span> * t.add * len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Info <span class="keyword">operator</span>+(Info a, Info b) &#123;</span><br><span class="line">    Info c;</span><br><span class="line">    <span class="comment">// a 和 b 一通操作弄出 c</span></span><br><span class="line">    c.sum = (a.sum + b.sum);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    vector&lt;Info&gt;<span class="built_in">a</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;a[i].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    LSGT&lt;Info,Tag&gt;<span class="built_in">sgt</span>(a);</span><br><span class="line">    <span class="type">int</span> m;cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> t,l,r;cin&gt;&gt;t&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        r+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> c;cin&gt;&gt;c;</span><br><span class="line">            sgt.<span class="built_in">Apply</span>(l,r,<span class="built_in">Tag</span>(c,<span class="number">0</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> c;cin&gt;&gt;c;</span><br><span class="line">            sgt.<span class="built_in">Apply</span>(l, r, <span class="built_in">Tag</span>(<span class="number">1</span>, c));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;sgt.<span class="built_in">query</span>(l,r).sum&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IOS;</span><br><span class="line">    <span class="type">int</span> T=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//cin&gt;&gt;T;</span></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调栈解决NGE问题"><a href="#单调栈解决NGE问题" class="headerlink" title="单调栈解决NGE问题"></a>单调栈解决NGE问题</h2><p>右边第一个严格大于当前元素的数的下标</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt;stk;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()&amp;&amp;a[stk.<span class="built_in">top</span>()]&lt;=a[i]) stk.<span class="built_in">pop</span>();</span><br><span class="line">    b[i]=stk.<span class="built_in">size</span>()?stk.<span class="built_in">top</span>():<span class="number">-1</span>;</span><br><span class="line">    stk.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调队列-滑动窗口"><a href="#单调队列-滑动窗口" class="headerlink" title="单调队列(滑动窗口)"></a>单调队列(滑动窗口)</h2><p>以最小值为例，最大值的区别就是第一行while pop时的条件的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="comment">//单调队列求最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;a[q.<span class="built_in">back</span>()]&gt;=a[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">//将队尾所有大于等于遍历到当前元素的数pop出去</span></span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">//新元素入队</span></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;i-k&gt;=q.<span class="built_in">front</span>()) q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="comment">//将已经划出去的队头pop出去</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) cout&lt;&lt;a[q.<span class="built_in">front</span>()]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="comment">//当前元素就是窗口值k之内最小的元素</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>快速查询多个字符串中的前缀和，时间复杂度为O(m),其中m是待查询&#x2F;插入的字符串长度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=x[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u]=++idx;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">        cnt[p]+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>,op=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=x[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> op;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">        op+=(cnt[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字典树也可以快速查询某个字符串有没有出现过"><a href="#字典树也可以快速查询某个字符串有没有出现过" class="headerlink" title="字典树也可以快速查询某个字符串有没有出现过"></a>字典树也可以快速查询某个字符串有没有出现过</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=x[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u]=++idx;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>,op=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> u=x[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    op+=cnt[p];</span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;T&gt; tr;</span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">tr</span>(n + <span class="number">1</span>, <span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, T c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, T c)</span></span>&#123;</span><br><span class="line">        <span class="built_in">modify</span>(l, c);</span><br><span class="line">        <span class="keyword">if</span> (r + <span class="number">1</span> &lt;= n) <span class="built_in">modify</span>(r + <span class="number">1</span>, -c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        T res = <span class="built_in">T</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find_first</span><span class="params">(T sum)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>; T val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = __lg(n); i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((ans | (<span class="number">1</span> &lt;&lt; i)) &lt;= n &amp;&amp; val + tr[ans | (<span class="number">1</span> &lt;&lt; i)] &lt; sum)&#123;</span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                val += tr[ans];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find_last</span><span class="params">(T sum)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>; T val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = __lg(n); i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((ans | (<span class="number">1</span> &lt;&lt; i)) &lt;= n &amp;&amp; val + tr[ans | (<span class="number">1</span> &lt;&lt; i)] &lt;= sum)&#123;</span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                val += tr[ans];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> BIT = Fenwick&lt;<span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="声明方式-2"><a href="#声明方式-2" class="headerlink" title="声明方式"></a>声明方式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BIT <span class="title">tr</span><span class="params">(n)</span></span>;<span class="comment">//n是大小</span></span><br><span class="line"><span class="comment">//注意输入的时候要从1-n输入,vactor开n+1;</span></span><br><span class="line">tr.<span class="built_in">modify</span>(n,k)<span class="comment">//第n个数加上k</span></span><br><span class="line">tr.<span class="built_in">modify</span>(<span class="number">1</span>,n,k)<span class="comment">//从1到n每个数加k</span></span><br><span class="line">tr.<span class="built_in">query</span>(x)<span class="comment">//查询第x个数    </span></span><br><span class="line"><span class="comment">//三星提醒：初始化的时候是tr.modify(pos,pos,c),这样才代表只给pos位置赋值c</span></span><br></pre></td></tr></table></figure><h2 id="树状数组求逆序对"><a href="#树状数组求逆序对" class="headerlink" title="树状数组求逆序对"></a>树状数组求逆序对</h2><h3 id="数值大的情况下要进行离散化-离散化下标从1开始"><a href="#数值大的情况下要进行离散化-离散化下标从1开始" class="headerlink" title="数值大的情况下要进行离散化,离散化下标从1开始"></a>数值大的情况下要进行离散化,离散化下标从1开始</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n);</span><br><span class="line">    <span class="function">BIT <span class="title">tr</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        tr.<span class="built_in">modify</span>(a[i],<span class="number">1</span>);</span><br><span class="line">        ans+=(i-tr.<span class="built_in">query</span>(a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组jiangly"><a href="#树状数组jiangly" class="headerlink" title="树状数组jiangly"></a>树状数组jiangly</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span> &#123;</span><br><span class="line">    <span class="type">int</span> n; vector&lt;T&gt;a;</span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="type">int</span> n_ = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n_)</span> </span>&#123;</span><br><span class="line">        n = n_;</span><br><span class="line">        a.<span class="built_in">assign</span>(n, T&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> T &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x + <span class="number">1</span>; i &lt;= n; i += i &amp; -i) &#123;</span><br><span class="line">            a[i - <span class="number">1</span>] = a[i - <span class="number">1</span>] + v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        T ans&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= i &amp; -i) &#123;</span><br><span class="line">            ans = ans + a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">rangeSum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(r) - <span class="built_in">sum</span>(l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">const</span> T &amp;k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        T cur&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span> &lt;&lt; std::__lg(n); i; i /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x + i &lt;= n &amp;&amp; cur + a[x + i - <span class="number">1</span>] &lt;= k) &#123;</span><br><span class="line">                x += i;</span><br><span class="line">                cur = cur + a[x - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h2><h3 id="解决RMQ问题，预处理复杂度为O-nlogn-O-1-查询-常数比线段树小"><a href="#解决RMQ问题，预处理复杂度为O-nlogn-O-1-查询-常数比线段树小" class="headerlink" title="解决RMQ问题，预处理复杂度为O(nlogn),O(1)查询,常数比线段树小"></a>解决RMQ问题，预处理复杂度为O(nlogn),O(1)查询,常数比线段树小</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ST</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;lg;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; mx, mn;</span><br><span class="line">    <span class="built_in">ST</span>(vector&lt;<span class="type">int</span>&gt;init)&#123;</span><br><span class="line">        n=init.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        lg.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            lg[i] = lg[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mx.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(lg[n] + <span class="number">1</span>));</span><br><span class="line">        mn.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(lg[n] + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            mx[i][<span class="number">0</span>] = init[i];</span><br><span class="line">            mn[i][<span class="number">0</span>] = init[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = lg[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">                mx[i][j] = <span class="built_in">max</span>(mx[i][j - <span class="number">1</span>], mx[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">                mn[i][j] = <span class="built_in">min</span>(mn[i][j - <span class="number">1</span>], mn[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getmax</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = lg[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(mx[l][k], mx[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getmin</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = lg[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(mn[l][k], mn[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解决区间gcd问题"><a href="#解决区间gcd问题" class="headerlink" title="解决区间gcd问题"></a>解决区间gcd问题</h3><p>预处理复杂度为$O(n(logn+logv))$,查询复杂度$O(logv)$,其中v为值域</p><p>该问题”区间gcd”中，线段树查询的复杂度为$O(logn+logv)$</p><p>ST表可以用来解决可重复贡献问题，例如「区间按位与」、「区间按位或」、「区间 GCD」，ST 表都能高效地解决。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ST</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;lg;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; g;</span><br><span class="line">    <span class="built_in">ST</span>(vector&lt;<span class="type">int</span>&gt;init)&#123;</span><br><span class="line">        n=init.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        lg.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            lg[i] = lg[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        g.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(lg[n] + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            g[i][<span class="number">0</span>] = init[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = lg[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">                g[i][j] = <span class="built_in">gcd</span>(g[i][j - <span class="number">1</span>], g[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k=lg[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(g[l][k], g[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="自动取模与排列组合"><a href="#自动取模与排列组合" class="headerlink" title="自动取模与排列组合"></a>自动取模与排列组合</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">3e5</span> + <span class="number">5</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">const</span> <span class="type">int</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ModInt</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> mod = T;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">ModInt</span>(<span class="type">int</span> x = <span class="number">0</span>) : <span class="built_in">x</span>(x % mod) &#123;&#125;</span><br><span class="line">    <span class="built_in">ModInt</span>(<span class="type">long</span> <span class="type">long</span> x) : <span class="built_in">x</span>(<span class="built_in">int</span>(x % mod)) &#123;&#125; </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> + (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="type">int</span> x0 = x + a.x; <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> - (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="type">int</span> x0 = x - a.x; <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; <span class="number">0</span> ? x0 + mod : x0); &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> * (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="built_in">ModInt</span>(<span class="number">1LL</span> * x * a.x % mod); &#125;</span><br><span class="line">    ModInt <span class="keyword">operator</span> / (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> *<span class="keyword">this</span> * a.<span class="built_in">inv</span>(); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> == (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> x == a.x; &#125;;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> != (<span class="type">const</span> ModInt &amp;a) <span class="type">const</span> &#123; <span class="keyword">return</span> x != a.x; &#125;;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> += (<span class="type">const</span> ModInt &amp;a) &#123; x += a.x; <span class="keyword">if</span> (x &gt;= mod) x -= mod; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> -= (<span class="type">const</span> ModInt &amp;a) &#123; x -= a.x; <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x += mod; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> *= (<span class="type">const</span> ModInt &amp;a) &#123; x = <span class="number">1LL</span> * x * a.x % mod; &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span> /= (<span class="type">const</span> ModInt &amp;a) &#123; *<span class="keyword">this</span> = *<span class="keyword">this</span> / a; &#125;</span><br><span class="line">    <span class="keyword">friend</span> ModInt <span class="keyword">operator</span> + (<span class="type">int</span> y, <span class="type">const</span> ModInt &amp;a)&#123; <span class="type">int</span> x0 = y + a.x; <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; mod ? x0 : x0 - mod); &#125;</span><br><span class="line">    <span class="keyword">friend</span> ModInt <span class="keyword">operator</span> - (<span class="type">int</span> y, <span class="type">const</span> ModInt &amp;a)&#123; <span class="type">int</span> x0 = y - a.x; <span class="keyword">return</span> <span class="built_in">ModInt</span>(x0 &lt; <span class="number">0</span> ? x0 + mod : x0); &#125;</span><br><span class="line">    <span class="keyword">friend</span> ModInt <span class="keyword">operator</span> * (<span class="type">int</span> y, <span class="type">const</span> ModInt &amp;a)&#123; <span class="keyword">return</span> <span class="built_in">ModInt</span>(<span class="number">1LL</span> * y * a.x % mod);&#125;</span><br><span class="line">    <span class="keyword">friend</span> ModInt <span class="keyword">operator</span> / (<span class="type">int</span> y, <span class="type">const</span> ModInt &amp;a)&#123; <span class="keyword">return</span> <span class="built_in">ModInt</span>(y) / a;&#125;</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> ModInt &amp;a) &#123; <span class="keyword">return</span> os &lt;&lt; a.x;&#125;</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, ModInt &amp;t)&#123;<span class="keyword">return</span> is &gt;&gt; t.x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ModInt <span class="title">pow</span><span class="params">(<span class="type">int64_t</span> n)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">ModInt <span class="title">res</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">mul</span><span class="params">(x)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res *= mul;</span><br><span class="line">            mul *= mul;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ModInt <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = x, b = mod, u = <span class="number">1</span>, v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="type">int</span> t = a / b;</span><br><span class="line">            a -= t * b; <span class="built_in">swap</span>(a, b);</span><br><span class="line">            u -= t * v; <span class="built_in">swap</span>(u, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u &lt; <span class="number">0</span>) u += mod;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> mint = ModInt&lt;mod&gt;;</span><br><span class="line"></span><br><span class="line">mint fact[maxn], invfact[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = invfact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; maxn; i++) fact[i] = fact[i - <span class="number">1</span>] * i;</span><br><span class="line">    invfact[maxn - <span class="number">1</span>] = fact[maxn - <span class="number">1</span>].<span class="built_in">inv</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = maxn - <span class="number">2</span>; i; i--)</span><br><span class="line">        invfact[i] = invfact[i + <span class="number">1</span>] * (i + <span class="number">1</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> mint <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span> || b &lt; <span class="number">0</span> || a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fact[a] * invfact[b] * invfact[a - b];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h2><h3 id="基础莫队"><a href="#基础莫队" class="headerlink" title="基础莫队"></a>基础莫队</h3><p>属于离线算法，解决数据范围在[1,1e5]范围内的题;</p><p>如果n，m同阶(n&#x3D;&#x3D;m),时间复杂度为$n\sqrt{n}$,排序按照左端点块顺序与右端点来排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;array&lt;<span class="type">int</span>,3&gt;&gt;<span class="built_in">query</span>(q<span class="number">+1</span>);</span><br><span class="line">    <span class="type">int</span> siz=(<span class="type">int</span>)(<span class="built_in">ceil</span>(<span class="built_in">pow</span>(n,<span class="number">0.5</span>)));</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">k</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        k[i]=(i<span class="number">-1</span>)/siz<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        query[i]=&#123;l,r,i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(query.<span class="built_in">begin</span>()<span class="number">+1</span>,query.<span class="built_in">end</span>(),[&amp;](<span class="keyword">auto</span> x,<span class="keyword">auto</span> y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k[x[<span class="number">0</span>]]!=k[y[<span class="number">0</span>]]) <span class="keyword">return</span> k[x[<span class="number">0</span>]]&lt;k[y[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">if</span>(k[x[<span class="number">0</span>]]&amp;<span class="number">1</span>) <span class="keyword">return</span> x[<span class="number">1</span>]&lt;y[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">1</span>]&gt;y[<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=<span class="number">0</span>,val=<span class="number">0</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">ans</span>(q<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">auto</span> add=[&amp;](<span class="type">int</span> x)&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> del=[&amp;](<span class="type">int</span> x)&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [ql,qr,id]:query[i];</span><br><span class="line">        <span class="keyword">while</span>(l&gt;ql) <span class="built_in">add</span>(a[--l]);</span><br><span class="line">        <span class="keyword">while</span>(r&lt;qr) <span class="built_in">add</span>(a[++r]);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;ql) <span class="built_in">del</span>(a[l++]);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;qr) <span class="built_in">del</span>(a[r--]);</span><br><span class="line">        ans[id]=val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h2><h3 id="HLD"><a href="#HLD" class="headerlink" title="HLD"></a>HLD</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HLD</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; siz, top, dep, parent, in, out, seq;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adj;</span><br><span class="line">    <span class="type">int</span> cur;</span><br><span class="line">    <span class="built_in">HLD</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">HLD</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        siz.<span class="built_in">resize</span>(n);</span><br><span class="line">        top.<span class="built_in">resize</span>(n);</span><br><span class="line">        dep.<span class="built_in">resize</span>(n);</span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        in.<span class="built_in">resize</span>(n);</span><br><span class="line">        out.<span class="built_in">resize</span>(n);</span><br><span class="line">        seq.<span class="built_in">resize</span>(n);</span><br><span class="line">        cur = <span class="number">0</span>;</span><br><span class="line">        adj.<span class="built_in">assign</span>(n, &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> root )</span> </span>&#123;</span><br><span class="line">        top[root] = root;</span><br><span class="line">        dep[root] = <span class="number">0</span>;</span><br><span class="line">        parent[root] = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(root);</span><br><span class="line">        <span class="built_in">dfs2</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           标记每个点的深度dep[]</span></span><br><span class="line"><span class="comment">           标记每个点的父亲parent[]</span></span><br><span class="line"><span class="comment">           标记每个非叶子节点的子树大小(含它自己)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (parent[u] != <span class="number">-1</span>) &#123;</span><br><span class="line">            adj[u].<span class="built_in">erase</span>(<span class="built_in">find</span>(adj[u].<span class="built_in">begin</span>(), adj[u].<span class="built_in">end</span>(), parent[u]));</span><br><span class="line">        &#125;</span><br><span class="line">        siz[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : adj[u]) &#123;</span><br><span class="line">            parent[v] = u;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(v);</span><br><span class="line">            siz[u] += siz[v];</span><br><span class="line">            <span class="keyword">if</span> (siz[v] &gt; siz[adj[u][<span class="number">0</span>]]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(v, adj[u][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        in[u] = cur++;</span><br><span class="line">        seq[in[u]] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u]) &#123;</span><br><span class="line">            top[v] = v == adj[u][<span class="number">0</span>] ? top[u] : v;</span><br><span class="line">            <span class="built_in">dfs2</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        out[u] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (top[u] != top[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dep[top[u]] &gt; dep[top[v]]) &#123;</span><br><span class="line">                u = parent[top[u]];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = parent[top[v]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dep[u] &lt; dep[v] ? u : v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dist</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回两点的距离</span></span><br><span class="line">        <span class="keyword">return</span> dep[u] + dep[v] - <span class="number">2</span> * dep[<span class="built_in">lca</span>(u, v)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向上跳k步，返回跳跃后的节点</span></span><br><span class="line">        <span class="keyword">if</span> (dep[u] &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> d = dep[u] - k;</span><br><span class="line">        <span class="keyword">while</span> (dep[top[u]] &gt; d) &#123;</span><br><span class="line">            u = parent[top[u]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> seq[in[u] - dep[u] + d];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAncester</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断u是否是v的祖先</span></span><br><span class="line">        <span class="keyword">return</span> in[u] &lt;= in[v] &amp;&amp; in[v] &lt; out[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rootedParent</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            在以u为根的子树中，找到v的直接父节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">swap</span>(u, v);</span><br><span class="line">        <span class="keyword">if</span> (u == v) &#123;</span><br><span class="line">            <span class="keyword">return</span> u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isAncester</span>(u, v)) &#123;</span><br><span class="line">            <span class="keyword">return</span> parent[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">upper_bound</span>(adj[u].<span class="built_in">begin</span>(), adj[u].<span class="built_in">end</span>(), v, [&amp;](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> in[x] &lt; in[y];</span><br><span class="line">        &#125;) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rootedSize</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 在以u为根的子树中，计算以v为根的子树的大小</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (u == v) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isAncester</span>(v, u)) &#123;</span><br><span class="line">            <span class="keyword">return</span> siz[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - siz[<span class="built_in">rootedParent</span>(u, v)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rootedLca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lca</span>(a, b) ^ <span class="built_in">lca</span>(b, c) ^ <span class="built_in">lca</span>(c, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="点权与线段树操作"><a href="#点权与线段树操作" class="headerlink" title="点权与线段树操作"></a>点权与线段树操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">HLD</span> &#123;</span><br><span class="line">    <span class="type">int</span> n,cur;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; siz, top, dep, parent, in, out, seq;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adj;</span><br><span class="line">    <span class="built_in">HLD</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        siz.<span class="built_in">resize</span>(n);</span><br><span class="line">        top.<span class="built_in">resize</span>(n);</span><br><span class="line">        dep.<span class="built_in">resize</span>(n);</span><br><span class="line">        parent.<span class="built_in">resize</span>(n);</span><br><span class="line">        in.<span class="built_in">resize</span>(n);</span><br><span class="line">        out.<span class="built_in">resize</span>(n);</span><br><span class="line">        seq.<span class="built_in">resize</span>(n);</span><br><span class="line">        cur = <span class="number">1</span>;</span><br><span class="line">        adj.<span class="built_in">assign</span>(n, &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> root )</span> </span>&#123;</span><br><span class="line">        top[root] = root;</span><br><span class="line">        dep[root] = <span class="number">0</span>;</span><br><span class="line">        parent[root] = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(root);</span><br><span class="line">        <span class="built_in">dfs2</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[u] != <span class="number">-1</span>) &#123;</span><br><span class="line">            adj[u].<span class="built_in">erase</span>(<span class="built_in">find</span>(adj[u].<span class="built_in">begin</span>(), adj[u].<span class="built_in">end</span>(), parent[u]));</span><br><span class="line">        &#125;</span><br><span class="line">        siz[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : adj[u]) &#123;</span><br><span class="line">            parent[v] = u;</span><br><span class="line">            dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs1</span>(v);</span><br><span class="line">            siz[u] += siz[v];</span><br><span class="line">            <span class="keyword">if</span> (siz[v] &gt; siz[adj[u][<span class="number">0</span>]]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(v, adj[u][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        in[u] = cur++;</span><br><span class="line">        seq[in[u]] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[u]) &#123;</span><br><span class="line">            top[v] = v == adj[u][<span class="number">0</span>] ? top[u] : v;</span><br><span class="line">            <span class="built_in">dfs2</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        out[u] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Info</span>, <span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LSGT</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(p) (p &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(p) (p &lt;&lt; 1 | 1)</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;Info&gt; info;</span><br><span class="line">    vector&lt;Tag&gt; tag;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">LSGT</span><span class="params">(vector&lt;T&gt; init1)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">init</span>(init1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">init</span><span class="params">(vector&lt;T&gt; init1)</span> </span>&#123;</span><br><span class="line">        n = init<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        info.<span class="built_in">assign</span>(<span class="number">4</span> &lt;&lt; __lg(n), <span class="built_in">Info</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>(<span class="number">4</span> &lt;&lt; __lg(n), <span class="built_in">Tag</span>());</span><br><span class="line">        <span class="keyword">auto</span> build = [&amp;](<span class="keyword">auto</span> self, <span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r - l == <span class="number">1</span>) &#123;</span><br><span class="line">                info[p] = init1[l];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">self</span>(self, <span class="built_in">l</span>(p), l, m);</span><br><span class="line">            <span class="built_in">self</span>(self, <span class="built_in">r</span>(p), m, r);</span><br><span class="line">            <span class="built_in">pull</span>(p);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">build</span>(build, <span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        info[p] = info[<span class="built_in">l</span>(p)] + info[<span class="built_in">r</span>(p)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">int</span> p, <span class="type">const</span> Tag&amp; v, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        info[p].<span class="built_in">apply</span>(v, len);</span><br><span class="line">        tag[p].<span class="built_in">apply</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">apply</span>(<span class="built_in">l</span>(p), tag[p], len / <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">apply</span>(<span class="built_in">r</span>(p), tag[p], len - len / <span class="number">2</span>);</span><br><span class="line">        tag[p] = <span class="built_in">Tag</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y <span class="keyword">or</span> r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Info</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x <span class="keyword">and</span> r &lt;= y) &#123;</span><br><span class="line">            <span class="keyword">return</span> info[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">push</span>(p, r - l);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="built_in">l</span>(p), l, m, x, y) + <span class="built_in">query</span>(<span class="built_in">r</span>(p), m, r, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Apply</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Tag &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= y <span class="keyword">or</span> r &lt;= x) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= x <span class="keyword">and</span> r &lt;= y) &#123;</span><br><span class="line">            <span class="built_in">apply</span>(p, v, r - l);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">push</span>(p, r - l);</span><br><span class="line">        <span class="built_in">Apply</span>(<span class="built_in">l</span>(p), l, m, x, y, v);</span><br><span class="line">        <span class="built_in">Apply</span>(<span class="built_in">r</span>(p), m, r, x, y, v);</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Apply</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> Tag &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Apply</span>(<span class="number">1</span>, <span class="number">0</span>, n, l, r, v);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> l(p)</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> r(p)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tag</span> &#123;</span><br><span class="line">    <span class="type">int</span> add;</span><br><span class="line">    <span class="built_in">Tag</span>(<span class="type">int</span> add1=<span class="number">0</span>):<span class="built_in">add</span>(add1)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(Tag t)</span> </span>&#123;</span><br><span class="line">        add+=(t.add);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(Tag t, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        sum += <span class="number">1LL</span> * t.add * len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Info <span class="keyword">operator</span>+(Info a, Info b) &#123;</span><br><span class="line">    Info c;</span><br><span class="line">    c.sum = (a.sum + b.sum);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,r,p;cin&gt;&gt;n&gt;&gt;m&gt;&gt;r&gt;&gt;p;</span><br><span class="line">    <span class="comment">//r为根,p为取模数</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">g</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="function">HLD <span class="title">t</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        t.<span class="built_in">addEdge</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    t.<span class="built_in">work</span>(r);</span><br><span class="line">    vector&lt;Info&gt;<span class="built_in">k</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        k[t.in[i]].sum=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    LSGT&lt;Info,Tag&gt;<span class="built_in">sgt</span>(k);</span><br><span class="line">    <span class="keyword">auto</span> range=[&amp;](<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)&#123;</span><br><span class="line">        <span class="keyword">while</span>(t.top[x]!=t.top[y])&#123;</span><br><span class="line">            <span class="keyword">if</span>(t.dep[t.top[x]]&lt;t.dep[t.top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">            sgt.<span class="built_in">Apply</span>(t.in[t.top[x]],t.in[x]<span class="number">+1</span>,z);</span><br><span class="line">            x=t.parent[t.top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t.dep[x]&gt;t.dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        sgt.<span class="built_in">Apply</span>(t.in[x],t.in[y]<span class="number">+1</span>,z);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> query=[&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(t.top[x]!=t.top[y])&#123;</span><br><span class="line">            <span class="keyword">if</span>(t.dep[t.top[x]]&lt;t.dep[t.top[y]]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">            ans=(ans+sgt.<span class="built_in">query</span>(t.in[t.top[x]],t.in[x]<span class="number">+1</span>).sum)%p;</span><br><span class="line">            x=t.parent[t.top[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t.dep[x]&gt;t.dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">        ans=(ans+sgt.<span class="built_in">query</span>(t.in[x],t.in[y]<span class="number">+1</span>).sum)%p;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> op;cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x,y,z;cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">            <span class="built_in">range</span>(x,y,z);<span class="comment">//区间加</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">query</span>(x,y)&lt;&lt;<span class="string">&quot;\n&quot;</span>;<span class="comment">//区间和</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x,z;cin&gt;&gt;x&gt;&gt;z;</span><br><span class="line">            sgt.<span class="built_in">Apply</span>(t.in[x],t.in[x]+t.siz[x],z);<span class="comment">//子树加</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">            cout&lt;&lt;(sgt.<span class="built_in">query</span>(t.in[x],t.in[x]+t.siz[x]).sum)%p&lt;&lt;<span class="string">&quot;\n&quot;</span>;<span class="comment">//子树和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h2><p>Persistent Segment Tree（可持久化权值线段树）</p><h3 id="区间静态第k小"><a href="#区间静态第k小" class="headerlink" title="区间静态第k小"></a>区间静态第k小</h3><p>包括离散化,pos-1是因为b数组下标从0开始</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r,rt,sum;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Node&gt;<span class="built_in">tr</span>(N&lt;&lt;<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=++cnt;</span><br><span class="line">    tr[p].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        tr[p].l=<span class="built_in">build</span>(l,mid);</span><br><span class="line">        tr[p].r=<span class="built_in">build</span>(mid<span class="number">+1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">update</span><span class="params">(<span class="type">int</span> pre,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=++cnt;</span><br><span class="line">    tr[p]=tr[pre];tr[p].sum++;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=mid)tr[p].l=<span class="built_in">update</span>(tr[pre].l,l,mid,x);</span><br><span class="line">        <span class="keyword">else</span> tr[p].r=<span class="built_in">update</span>(tr[pre].r,mid<span class="number">+1</span>,r,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> x=tr[tr[v].l].sum-tr[tr[u].l].sum;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=k) <span class="keyword">return</span> <span class="built_in">query</span>(tr[u].l,tr[v].l,l,mid,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(tr[u].r,tr[v].r,mid<span class="number">+1</span>,r,k-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n),<span class="built_in">b</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        b[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());</span><br><span class="line">    b.<span class="built_in">erase</span>(<span class="built_in">unique</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>()),b.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> len=b.<span class="built_in">size</span>();</span><br><span class="line">    tr[<span class="number">0</span>].rt=<span class="built_in">build</span>(<span class="number">1</span>,len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">lower_bound</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>(),a[i])-b.<span class="built_in">begin</span>()<span class="number">+1</span>;</span><br><span class="line">        tr[i<span class="number">+1</span>].rt=<span class="built_in">update</span>(tr[i].rt,<span class="number">1</span>,len,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> l,r,k;cin&gt;&gt;l&gt;&gt;r&gt;&gt;k;<span class="comment">//求区间[l,r]内的第k小</span></span><br><span class="line">        <span class="type">int</span> pos=<span class="built_in">query</span>(tr[l<span class="number">-1</span>].rt,tr[r].rt,<span class="number">1</span>,len,k);</span><br><span class="line">        cout&lt;&lt;b[pos<span class="number">-1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FHQ-Treap"><a href="#FHQ-Treap" class="headerlink" title="FHQ Treap"></a>FHQ Treap</h2><p>操作复杂度$log_2n$，</p><p>能够解决</p><ol><li>插入一个数 x。</li><li>删除一个数 x（若有多个相同的数，应只删除一个）。</li><li>定义<strong>排名</strong>为比当前数小的数的个数 +1。查询 x的排名。</li><li>查询数据结构中排名为 x的数。</li><li>求 x 的前驱（前驱定义为小于 x，且最大的数）。</li><li>求 x 的后继（后继定义为大于 x，且最小的数）。</li><li></li></ol>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/">XCPC模板</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">XCPC数据结构</category>
      
      
      <category domain="http://iokanux.com/tags/HLD/">HLD</category>
      
      <category domain="http://iokanux.com/tags/ST%E8%A1%A8/">ST表</category>
      
      <category domain="http://iokanux.com/tags/DSU/">DSU</category>
      
      <category domain="http://iokanux.com/tags/SegmentTree/">SegmentTree</category>
      
      <category domain="http://iokanux.com/tags/LazySegmentTree/">LazySegmentTree</category>
      
      <category domain="http://iokanux.com/tags/Monotonic-Stack/">Monotonic Stack</category>
      
      <category domain="http://iokanux.com/tags/Monotonic-Deque/">Monotonic Deque</category>
      
      <category domain="http://iokanux.com/tags/Trie/">Trie</category>
      
      <category domain="http://iokanux.com/tags/Fenwick/">Fenwick</category>
      
      <category domain="http://iokanux.com/tags/Mo-s-Algorithm/">Mo&#39;s Algorithm</category>
      
      <category domain="http://iokanux.com/tags/PST/">PST</category>
      
      <category domain="http://iokanux.com/tags/FHQ-Treap/">FHQ Treap</category>
      
      <category domain="http://iokanux.com/tags/Inversion/">Inversion</category>
      
      
      <comments>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
