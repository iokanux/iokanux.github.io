<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>iokanux</title>
    <link>http://iokanux.com/</link>
    
    <atom:link href="http://iokanux.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Do something with the world</description>
    <pubDate>Fri, 13 Sep 2024 06:13:05 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>2024CCPC网络赛</title>
      <link>http://iokanux.com/2024/09/12/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/2024CCPC%E7%BD%91%E7%BB%9C%E8%B5%9B/</link>
      <guid>http://iokanux.com/2024/09/12/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/2024CCPC%E7%BD%91%E7%BB%9C%E8%B5%9B/</guid>
      <pubDate>Thu, 12 Sep 2024 11:03:33 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;B-军训-II&quot;&gt;&lt;a href=&quot;#B-军训-II&quot; class=&quot;headerlink&quot; title=&quot;B 军训 II&quot;&gt;&lt;/a&gt;B 军训 II&lt;/h2&gt;&lt;p&gt;对于这类问题一个很经典的思路就是求每个位置的贡献&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h2 id="B-军训-II"><a href="#B-军训-II" class="headerlink" title="B 军训 II"></a>B 军训 II</h2><p>对于这类问题一个很经典的思路就是求每个位置的贡献</p><p>首先能感性的判断出来从小到大&#x2F;从大到小排不整齐度是最小的(因为最大&#x2F;最小值都是依次递增的)</p><p>然后可以理性的证明一下：</p><p>对于已经排好序的数组a 有a1&lt;&#x3D;a2&lt;&#x3D;a3&lt;&#x3D;…&lt;&#x3D;an,此时交换a2,ak(假设a2&lt;ak);</p><p>交换完的结果就是l在[1,k-1],r在[l,k-1]的区间内最大值变大，最小值不变,l在[k,n]，r在[l,n]的区间内最大值不变，最小值变小</p><p>身高相同的人可以交换位置,$A_{k}^k$,表示k个身高相同的人的排列方案,</p><p>注意特判全相等序列(从小到大和从大到小排列一样)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n);</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];mp[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">            ans1+=a[j]-a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> A=[&amp;](<span class="type">int</span> x)&#123;</span><br><span class="line">        <span class="type">int</span> tem=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)&#123;</span><br><span class="line">            tem=(tem*i)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tem;</span><br><span class="line">    &#125;;</span><br><span class="line">    a.<span class="built_in">erase</span>(<span class="built_in">unique</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:a)&#123;</span><br><span class="line">        ans2=(ans2*<span class="built_in">A</span>(mp[i]))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()!=<span class="number">1</span>) ans2=(ans2*<span class="number">2</span>)%mod;</span><br><span class="line">    cout&lt;&lt;ans1&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ans2&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="K-取沙子游戏"><a href="#K-取沙子游戏" class="headerlink" title="K 取沙子游戏"></a>K 取沙子游戏</h2><p>考虑n的奇偶性</p><p>当n为奇数时，第一手取1必然获胜</p><p>当n为偶数时，考虑变成必胜态，即将n减去某两个数得到奇数，可知这两个数必然为一奇一偶，且先手必选偶数，当先手选择奇数后，后手必胜。</p><p>由于选择的是偶数，初步猜想寄了，因为后手必然不会选择奇数，所以后手选择偶数阻止先手到达必胜态，此时第二轮到达先手手上的数还是偶数，这样归纳一下可以发现当n为偶数的时候，先后手都只会选择偶数</p><p>考虑二进制，当先手第一次选择lowbit(n)时，后手无论选择什么我们都和其选择一样即可获胜，因为二进制下需要偶数次选择偶数才能将这个数归零</p>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/">XCPC系列赛</category>
      
      
      
      <comments>http://iokanux.com/2024/09/12/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/2024CCPC%E7%BD%91%E7%BB%9C%E8%B5%9B/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ICPC·2020·小米网络赛二</title>
      <link>http://iokanux.com/2024/09/11/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/ICPC%C2%B72020%C2%B7%E5%B0%8F%E7%B1%B3%E7%BD%91%E7%BB%9C%E8%B5%9B%E4%BA%8C/</link>
      <guid>http://iokanux.com/2024/09/11/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/ICPC%C2%B72020%C2%B7%E5%B0%8F%E7%B1%B3%E7%BD%91%E7%BB%9C%E8%B5%9B%E4%BA%8C/</guid>
      <pubDate>Wed, 11 Sep 2024 10:55:39 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;G-Shift-and-Reverse&quot;&gt;&lt;a href=&quot;#G-Shift-and-Reverse&quot; class=&quot;headerlink&quot; title=&quot;G Shift and Reverse&quot;&gt;&lt;/a&gt;G Sh</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h2 id="G-Shift-and-Reverse"><a href="#G-Shift-and-Reverse" class="headerlink" title="G Shift and Reverse"></a>G Shift and Reverse</h2><h3 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h3><p>Bobo has a sequence $a_1,a_2,\dots,a_n$. He can rearrange the sequence using the following operation any number of times:  </p><p>+ Select an integer i ($1 \le i \le n$) and change the sequence to $a_i, a_{i-1}, \dots, a_1, a_n, a_{n-1}, \dots, a_{i+1}$.  </p><p>Bobo would like to know the number of different sequences can be obtained modulo $(10^9+7)$.</p><p>波波有一个序列$a_1,a_2,\dots,a_n$。他可以使用以下操作任意次数重新排列序列:</p><p>选择整数i($1 \le i \le n$)并将序列更改为$a_i, a_{i-1}, \dots, a_1, a_n, a_{n-1}, \dots, a_{i+1}$。</p><p>Bobo想知道有多少个不同的序列对$(10^9+7)$取模。</p><h3 id="Analyse"><a href="#Analyse" class="headerlink" title="Analyse"></a>Analyse</h3><p>遇到题目没思路就先模拟一下</p><p>一个新的数组a,标号从a1-an,假定选择k进行反转操作，执行操作后的序列为$a_{k},a_{k-1}…a_{k+2},a_{k+1},$</p>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/">XCPC系列赛</category>
      
      
      
      <comments>http://iokanux.com/2024/09/11/XCPC/XCPC%E7%B3%BB%E5%88%97%E8%B5%9B/ICPC%C2%B72020%C2%B7%E5%B0%8F%E7%B1%B3%E7%BD%91%E7%BB%9C%E8%B5%9B%E4%BA%8C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>矩阵相关</title>
      <link>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E8%AE%BA/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/</link>
      <guid>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E8%AE%BA/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/</guid>
      <pubDate>Wed, 11 Sep 2024 10:12:22 GMT</pubDate>
      
        
        
      <description>&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;Matrix-Determinant-Lemma-矩阵行列式引理&quot;&gt;&lt;a href=&quot;#Matrix-Determinant-Lemma-矩阵行列式引理&quot; class=&quot;headerlink&quot; title=&quot;Mat</description>
        
      
      
      
      <content:encoded><![CDATA[<span id="more"></span><h2 id="Matrix-Determinant-Lemma-矩阵行列式引理"><a href="#Matrix-Determinant-Lemma-矩阵行列式引理" class="headerlink" title="Matrix Determinant Lemma(矩阵行列式引理)"></a>Matrix Determinant Lemma(矩阵行列式引理)</h2><h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><p>对于可逆矩阵A,存在det($A+uv^T$)&#x3D;det(A)*($1+v^TA^{-1}u$)</p><h3 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h3><ol><li><a href="https://ac.nowcoder.com/acm/contest/7502/D">D-Determinant_2020ICPC·小米 网络选拔赛第二场 (nowcoder.com)</a></li><li></li></ol>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/">XCPC模板</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E8%AE%BA/">XCPC数论</category>
      
      
      
      <comments>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E8%AE%BA/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>子序列相关</title>
      <link>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AD%90%E5%BA%8F%E5%88%97%E7%9B%B8%E5%85%B3/</link>
      <guid>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AD%90%E5%BA%8F%E5%88%97%E7%9B%B8%E5%85%B3/</guid>
      <pubDate>Wed, 11 Sep 2024 05:40:25 GMT</pubDate>
      
      <description>&lt;p&gt;动态规划中的子序列问题&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>动态规划中的子序列问题</p><span id="more"></span><p>子序列(subsequence)不要求连续，但相对顺序不能改变</p><h2 id="最长上升子序列-LIS"><a href="#最长上升子序列-LIS" class="headerlink" title="最长上升子序列(LIS)"></a>最长上升子序列(LIS)</h2><p>Longest Increasing Subsequence</p><h3 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i]表示以num[i]结尾的最长上升子序列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    dp[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[j]&lt;num[i])&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i],dp[j]<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="O-nlogn"><a href="#O-nlogn" class="headerlink" title="O(nlogn)"></a>O(nlogn)</h3><p>二分法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;stk;<span class="comment">//模拟堆栈</span></span><br><span class="line">    stk.<span class="built_in">push_back</span>(a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;stk.<span class="built_in">back</span>())&#123;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            *<span class="built_in">lower_bound</span>(stk.<span class="built_in">begin</span>(),stk.<span class="built_in">end</span>(),a[i])=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//stk.size()为LIS长度</span></span><br></pre></td></tr></table></figure><h2 id="最长下降子序列-LDS"><a href="#最长下降子序列-LDS" class="headerlink" title="最长下降子序列(LDS)"></a>最长下降子序列(LDS)</h2><p>Longest Decreasing Subsequence,反方向的LIS</p><h3 id="O-nlogn-1"><a href="#O-nlogn-1" class="headerlink" title="O(nlogn)"></a>O(nlogn)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;stk;<span class="comment">//模拟堆栈</span></span><br><span class="line">    stk.<span class="built_in">push_back</span>(a[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;stk.<span class="built_in">back</span>())&#123;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            *<span class="built_in">lower_bound</span>(stk.<span class="built_in">begin</span>(),stk.<span class="built_in">end</span>(),a[i])=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="最长不上升子序列-LNIS"><a href="#最长不上升子序列-LNIS" class="headerlink" title="最长不上升子序列(LNIS)"></a>最长不上升子序列(LNIS)</h2><p>Longest Non-increasing Subsequence</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stk.<span class="built_in">push_back</span>(a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=stk.<span class="built_in">back</span>())&#123;</span><br><span class="line">            stk.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            *<span class="built_in">upper_bound</span>(stk.<span class="built_in">begin</span>(),stk.<span class="built_in">end</span>(),a[i],<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;())=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列-LCS"><a href="#最长公共子序列-LCS" class="headerlink" title="最长公共子序列(LCS)"></a>最长公共子序列(LCS)</h2><p>Longest Common Subsequence</p><h3 id="O-nm"><a href="#O-nm" class="headerlink" title="O(nm)"></a>O(nm)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        dp[i][j]=<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">        <span class="keyword">if</span>(s[i]==t[j])&#123;</span><br><span class="line">           dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="O-nlogm"><a href="#O-nlogm" class="headerlink" title="O(nlogm)"></a>O(nlogm)</h3><p>一般情况下时间复杂度为O(nlogm)，但是最坏可退化至O(nm)</p><p>具体就是将LCS问题转化为LIS问题来做</p>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/">XCPC模板</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">XCPC动态规划</category>
      
      
      
      <comments>http://iokanux.com/2024/09/11/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%AD%90%E5%BA%8F%E5%88%97%E7%9B%B8%E5%85%B3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>拓扑排序</title>
      <link>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
      <guid>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid>
      <pubDate>Tue, 10 Sep 2024 13:45:15 GMT</pubDate>
      
      
      
      
      
      
      <comments>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%9B%BE%E8%AE%BA/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Dijkstra</title>
      <link>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%9B%BE%E8%AE%BA/Dijkstra/</link>
      <guid>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%9B%BE%E8%AE%BA/Dijkstra/</guid>
      <pubDate>Tue, 10 Sep 2024 13:41:56 GMT</pubDate>
      
      <description>&lt;p&gt;只介绍堆优化版的Dijikstra写法&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>只介绍堆优化版的Dijikstra写法</p><span id="more"></span><h2 id="Dijikstra"><a href="#Dijikstra" class="headerlink" title="Dijikstra"></a>Dijikstra</h2><p>堆优化版本能在mlogn时间复杂度内求fi到se的最短路径(m为边,n为点)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> dijkstra=[&amp;](<span class="type">int</span> fi,<span class="type">int</span> se)&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">dist</span>(n<span class="number">+10</span>,inf);</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt;<span class="built_in">st</span>(n<span class="number">+10</span>,<span class="literal">false</span>);</span><br><span class="line">        dist[fi] = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">        heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, fi&#125;);</span><br><span class="line">        <span class="keyword">while</span> (heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line">            <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">            st[ver] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i:g[ver])&#123;</span><br><span class="line">                <span class="type">int</span> j = i.first;</span><br><span class="line">                <span class="keyword">if</span> (dist[j] &gt; dist[ver] + i.second)&#123;</span><br><span class="line">                    dist[j] = dist[ver] + i.second;</span><br><span class="line">                    heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist[se];</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/">XCPC模板</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%9B%BE%E8%AE%BA/">XCPC图论</category>
      
      
      
      <comments>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E5%9B%BE%E8%AE%BA/Dijkstra/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>哈希</title>
      <link>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C/</link>
      <guid>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C/</guid>
      <pubDate>Tue, 10 Sep 2024 13:34:19 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;双哈希基础封装&quot;&gt;&lt;a href=&quot;#双哈希基础封装&quot; class=&quot;headerlink&quot; title=&quot;双哈希基础封装&quot;&gt;&lt;/a&gt;双哈希基础封装&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="双哈希基础封装"><a href="#双哈希基础封装" class="headerlink" title="双哈希基础封装"></a>双哈希基础封装</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Shash</span>&#123;  </span><br><span class="line">    <span class="type">const</span> ll base[<span class="number">2</span>]=&#123;<span class="number">29</span>,<span class="number">31</span>&#125;;</span><br><span class="line">    <span class="comment">//base存储基数</span></span><br><span class="line">    <span class="type">const</span> ll hashmod[<span class="number">2</span>]=&#123;(ll)<span class="number">1e9</span><span class="number">+9</span>,<span class="number">998244353</span>&#125;;</span><br><span class="line">    <span class="comment">//hashmod存储模数</span></span><br><span class="line">    array&lt;vector&lt;ll&gt;,2&gt;hsh;</span><br><span class="line">    array&lt;vector&lt;ll&gt;,2&gt;pwMod;</span><br><span class="line">    <span class="comment">//hsh[2] 和 pwMod[2]：这两个二维 vector 分别用于存储哈希值和幂模值。</span></span><br><span class="line">    <span class="comment">//其中，hsh[i][j] 表示字符串前 j 个字符在基数 base[i] 和模数 hashmod[i] 下的哈希值；</span></span><br><span class="line">    <span class="comment">//pwMod[i][j] 表示基数 base[i] 的 j 次幂对 hashmod[i] 取模的结果。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(string S)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n=S.<span class="built_in">size</span>();S=<span class="string">&#x27; &#x27;</span>+S;</span><br><span class="line">        hsh[<span class="number">0</span>].<span class="built_in">resize</span>(n<span class="number">+1</span>),hsh[<span class="number">1</span>].<span class="built_in">resize</span>(n<span class="number">+1</span>);</span><br><span class="line">        pwMod[<span class="number">0</span>].<span class="built_in">resize</span>(n<span class="number">+1</span>),pwMod[<span class="number">1</span>].<span class="built_in">resize</span>(n<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)&#123;</span><br><span class="line">            pwMod[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)&#123;</span><br><span class="line">                pwMod[i][j]=pwMod[i][j<span class="number">-1</span>]*base[i]%hashmod[i];</span><br><span class="line">                hsh[i][j]=(hsh[i][j<span class="number">-1</span>]*base[i]+S[j])%hashmod[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get函数输出[l,r]这段字符的哈希值,first是第一个模数下哈希值,second是第二个</span></span><br><span class="line">    pair&lt;ll,ll&gt;<span class="built_in">get</span>(<span class="type">int</span> l,<span class="type">int</span> r)&#123;</span><br><span class="line">        pair&lt;ll,ll&gt; ans;</span><br><span class="line">        ans.first=(hsh[<span class="number">0</span>][r]-hsh[<span class="number">0</span>][l<span class="number">-1</span>]*pwMod[<span class="number">0</span>][r-l<span class="number">+1</span>])%hashmod[<span class="number">0</span>];</span><br><span class="line">        ans.second=(hsh[<span class="number">1</span>][r]-hsh[<span class="number">1</span>][l<span class="number">-1</span>]*pwMod[<span class="number">1</span>][r-l<span class="number">+1</span>])%hashmod[<span class="number">1</span>];</span><br><span class="line">        ans.first=(ans.first+hashmod[<span class="number">0</span>])%hashmod[<span class="number">0</span>];</span><br><span class="line">        ans.second=(ans.second+hashmod[<span class="number">1</span>])%hashmod[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(Shash &amp;a,<span class="type">int</span> la,<span class="type">int</span> ra,Shash &amp;b,<span class="type">int</span> lb,<span class="type">int</span> rb)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">get</span>(la,ra)==b.<span class="built_in">get</span>(lb,rb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Employ"><a href="#Employ" class="headerlink" title="Employ"></a>Employ</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Shash a;</span><br><span class="line">a.<span class="built_in">init</span>(s)<span class="comment">//s是待处理字符串</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">same</span>(a,l,r,b,l,r))<span class="comment">//判断字符串a,b在l,r区间内是否相等</span></span><br><span class="line"><span class="comment">//该模板下标从1开始    </span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/">XCPC模板</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">XCPC数据结构</category>
      
      
      
      <comments>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ST表</title>
      <link>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ST%E8%A1%A8/</link>
      <guid>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ST%E8%A1%A8/</guid>
      <pubDate>Tue, 10 Sep 2024 13:30:18 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;ST表基础封装&quot;&gt;&lt;a href=&quot;#ST表基础封装&quot; class=&quot;headerlink&quot; title=&quot;ST表基础封装&quot;&gt;&lt;/a&gt;ST表基础封装&lt;/h2&gt;&lt;p&gt;解决RMQ问题，不支持静态查询，预处理复杂度为O(nlog(n))，O(1)查询，常数比线段树小&lt;/</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="ST表基础封装"><a href="#ST表基础封装" class="headerlink" title="ST表基础封装"></a>ST表基础封装</h2><p>解决RMQ问题，不支持静态查询，预处理复杂度为O(nlog(n))，O(1)查询，常数比线段树小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ST</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; in1, in2, lg;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; Max, Min;</span><br><span class="line">    <span class="built_in">ST</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">in1</span>(n + <span class="number">1</span>), <span class="built_in">in2</span>(n + <span class="number">1</span>), <span class="built_in">lg</span>(n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            lg[i] = lg[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Max.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(lg[n] + <span class="number">1</span>));</span><br><span class="line">        Min.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(lg[n] + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Max[i][<span class="number">0</span>] = in1[i];</span><br><span class="line">            Min[i][<span class="number">0</span>] = in2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = lg[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">                Max[i][j] = <span class="built_in">max</span>(Max[i][j - <span class="number">1</span>], Max[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">                Min[i][j] = <span class="built_in">min</span>(Min[i][j - <span class="number">1</span>], Min[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = lg[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(Max[l][k], Max[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(l, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> k = lg[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(Min[l][k], Min[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/">XCPC模板</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">XCPC数据结构</category>
      
      
      
      <comments>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ST%E8%A1%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>树状数组</title>
      <link>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</link>
      <guid>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</guid>
      <pubDate>Tue, 10 Sep 2024 13:25:38 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;树状数组基础封装&quot;&gt;&lt;a href=&quot;#树状数组基础封装&quot; class=&quot;headerlink&quot; title=&quot;树状数组基础封装&quot;&gt;&lt;/a&gt;树状数组基础封装&lt;/h2&gt;&lt;p&gt; &lt;strong&gt;Fenwick Tree&lt;/strong&gt; &lt;/p&gt;
&lt;figure cl</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="树状数组基础封装"><a href="#树状数组基础封装" class="headerlink" title="树状数组基础封装"></a>树状数组基础封装</h2><p> <strong>Fenwick Tree</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;T&gt; tr;</span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">tr</span>(n + <span class="number">1</span>, <span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x, T c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) tr[i] += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, T c)</span></span>&#123;</span><br><span class="line">        <span class="built_in">modify</span>(l, c);</span><br><span class="line">        <span class="keyword">if</span> (r + <span class="number">1</span> &lt;= n) <span class="built_in">modify</span>(r + <span class="number">1</span>, -c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        T res = <span class="built_in">T</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) res += tr[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find_first</span><span class="params">(T sum)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>; T val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = __lg(n); i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((ans | (<span class="number">1</span> &lt;&lt; i)) &lt;= n &amp;&amp; val + tr[ans | (<span class="number">1</span> &lt;&lt; i)] &lt; sum)&#123;</span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                val += tr[ans];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find_last</span><span class="params">(T sum)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>; T val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = __lg(n); i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((ans | (<span class="number">1</span> &lt;&lt; i)) &lt;= n &amp;&amp; val + tr[ans | (<span class="number">1</span> &lt;&lt; i)] &lt;= sum)&#123;</span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                val += tr[ans];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> BIT = Fenwick&lt;<span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="Employ"><a href="#Employ" class="headerlink" title="Employ"></a>Employ</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BIT <span class="title">tr</span><span class="params">(n)</span></span>;<span class="comment">//n是大小</span></span><br><span class="line"><span class="comment">//注意输入的时候要从1-n输入,vactor开n+1;</span></span><br><span class="line">tr.<span class="built_in">modify</span>(n,k)<span class="comment">//第n个数加上k</span></span><br><span class="line">tr.<span class="built_in">modify</span>(<span class="number">1</span>,n,k)<span class="comment">//从1到n每个数加k</span></span><br><span class="line">tr.<span class="built_in">query</span>(x)<span class="comment">//查询第x个数    </span></span><br><span class="line"><span class="comment">//三星提醒：初始化的时候是tr.modify(pos,pos,c),这样才代表只给pos位置赋值c</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/">XCPC模板</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">XCPC数据结构</category>
      
      
      
      <comments>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>并查集</title>
      <link>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
      <guid>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
      <pubDate>Tue, 10 Sep 2024 13:21:08 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;并查集基础封装&quot;&gt;&lt;a href=&quot;#并查集基础封装&quot; class=&quot;headerlink&quot; title=&quot;并查集基础封装&quot;&gt;&lt;/a&gt;并查集基础封装&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Disjoint Set Union&lt;/strong&gt;&lt;/p&gt;
&lt;figure cl</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="并查集基础封装"><a href="#并查集基础封装" class="headerlink" title="并查集基础封装"></a>并查集基础封装</h2><p><strong>Disjoint Set Union</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; f,siz;</span><br><span class="line">    <span class="built_in">DSU</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">init</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        f.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        siz.<span class="built_in">assign</span>(n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x]) &#123;</span><br><span class="line">            x = f[x] = f[f[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x);</span><br><span class="line">        y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        f[y] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> siz[<span class="built_in">find</span>(x)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Employ"><a href="#Employ" class="headerlink" title="Employ"></a>Employ</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DSU <span class="title">dsu</span><span class="params">(N)</span><span class="comment">//声明一个大小为N，名称为dsu的并查集</span></span></span><br><span class="line"><span class="function">dsu.<span class="title">merge</span><span class="params">(a,b)</span><span class="comment">//合并a,b</span></span></span><br><span class="line"><span class="function">dsu.<span class="title">find</span><span class="params">(x)</span><span class="comment">//找到x的祖宗节点</span></span></span><br><span class="line"><span class="function">dsu.size[dsu.<span class="title">find</span><span class="params">(x)</span>]<span class="comment">//以x为祖宗节点的个数 </span></span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://iokanux.com/categories/XCPC/">XCPC</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/">XCPC模板</category>
      
      <category domain="http://iokanux.com/categories/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">XCPC数据结构</category>
      
      
      
      <comments>http://iokanux.com/2024/09/10/XCPC/XCPC%E6%A8%A1%E6%9D%BF/XCPC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
